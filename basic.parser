%{
#include <cstdint>
#include <cwchar>
#include <string>
#include <memory>
#include <iostream>
#include <vector>
#include <cassert>
#include "tokenizer.h"
#include "ast/all.h"

using namespace std;

struct ParserValueType final
{
    Token token;
    shared_ptr<AST::Base> node;
    vector<shared_ptr<AST::Base>> nodes; // for lists
    explicit ParserValueType(TokenType tokenType = TokenType::TTEOF)
        : token(tokenType), node(nullptr)
    {
    }
    explicit ParserValueType(char tokenType)
        : token((TokenType)tokenType), node(nullptr)
    {
    }
    explicit ParserValueType(Token token)
        : token(token), node(nullptr)
    {
    }
    explicit ParserValueType(shared_ptr<const AST::Base> node)
        : token(), node(const_pointer_cast<AST::Base>(node))
    {
    }
    explicit ParserValueType(vector<shared_ptr<AST::Base>> nodes)
        : token(), node(nullptr), nodes(nodes)
    {
    }
    explicit ParserValueType(vector<shared_ptr<const AST::Base>> nodes)
        : token(), node(nullptr)
    {
        this->nodes.reserve(nodes.size());
        for(shared_ptr<const AST::Base> n : nodes)
        {
            this->nodes.push_back(const_pointer_cast<AST::Base>(n));
        }
    }
    bool operator ==(const ParserValueType &rt) const
    {
        return token.type == rt.token.type && node == rt.node;
    }
    bool operator !=(const ParserValueType &rt) const
    {
        return token.type != rt.token.type || node != rt.node;
    }
};

class ParserBase;

vector<shared_ptr<AST::SymbolTable>> &getSymbolTableStack(ParserBase *parser);

inline bool symbolExistsGlobal(ParserBase *parser, const wstring &name)
{
    vector<shared_ptr<AST::SymbolTable>> &sts = getSymbolTableStack(parser);
    for(auto i = sts.rbegin(); i != sts.rend(); ++i)
    {
        if((*i)->exists(name))
            return true;
    }
    return false;
}

inline void handleError(Location location, const wstring &msg)
{
    throw ParserError(location, msg);
}

inline void handleErrorNotImplemented(Location location, const wstring &what)
{
    handleError(location, what + L" not implemented");
}

inline void handleErrorNotImplemented(Token t)
{
    handleErrorNotImplemented(t.location, t.svalue);
}

inline const AST::Symbol &getSymbolGlobal(ParserBase *parser, Location location, const wstring &name)
{
    vector<shared_ptr<AST::SymbolTable>> &sts = getSymbolTableStack(parser);
    for(auto i = sts.rbegin(); i != sts.rend(); ++i)
    {
        if((*i)->exists(name))
            return (*i)->get(name);
    }
    handleError(location, L"undeclared identifier : " + name);
    throw logic_error("shouldn't be here");
}

inline const AST::Symbol &getSymbolGlobal(ParserBase *parser, Token t)
{
    return getSymbolGlobal(parser, t.location, t.svalue);
}

shared_ptr<AST::CodeBlock> parseAll(shared_ptr<InputStream> is);
shared_ptr<AST::Procedure> getContainingProcedure(ParserBase *parser);
void pushContainingProcedure(ParserBase *parser, shared_ptr<AST::Procedure> procedure);
void popContainingProcedure(ParserBase *parser);
vector<shared_ptr<AST::DoStatement>> &getDoStatementStack(ParserBase *parser);
vector<shared_ptr<AST::ForStatement>> &getForStatementStack(ParserBase *parser);
vector<shared_ptr<AST::WhileStatement>> &getWhileStatementStack(ParserBase *parser);

%}
%option SymbolPrefix "TokenType::TT"
%option ValueType "ParserValueType"
%option "UseC++11"
%option "ClassName" "ParserBase"
%token Id
%token StringLiteral
%token IntegerLiteral
%token SingleLiteral
%token DoubleLiteral
%token LogicalGE
%token LogicalLE
%token LogicalNE
%token Abs
%token And
%token Array
%token As
%token Asc
%token ATn
%token Boolean
%token ByRef
%token ByVal
%token Case
%token Cast
%token CBool
%token CDbl
%token CInt
%token CI8
%token CI16
%token CI32
%token CI64
%token CPtr
%token CSng
%token CStr
%token CU8
//%token CByte
%token CU16
%token CU32
%token CU64
%token Chr
%token Cos
%token Dim
%token Declare
%token Do
%token Double
%token Else
%token ElseIf
%token End
%token Exit
%token Exp
%token False
%token For
%token Function
%token Hex
%token If
%token InStr
%token Int
%token Integer
%token Int8
%token Int16
%token Int32
%token Int64
%token Is
%token LBound
%token LCase
%token Left
%token Len
%token Log
%token Loop
%token LTrim
%token Mid
%token Mod
%token Next
%token Not
%token Oct
%token Of
%token Or
%token Pointer
%token Right
%token RTrim
%token Select
%token Sgn
%token Sin
%token Single
%token Space
%token Sqr
%token Static
%token Step
%token Str
%token String
%token Sub
%token Tan
%token Then
%token To
%token True
%token Type
%token TypeOf
%token UBound
%token UCase
%token UInt8
//%token Byte
%token UInt16
%token UInt32
%token UInt64
%token Until
%token Val
%token WEnd
%token While
%token Xor
%%

program: codeBlock {$$ = $1;}
    | newLine codeBlock {$$ = $2;}
    ;

getLocation: {$$ = peekToken;}
    ;

variableDeclaration: Dim {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{});}
    | Dim declarationPartList {$$ = $2;}
    ;

typeStart: Type Id newLine
    {
        wstring name = $2.token.svalue;
        Location location = $2.token.location;
        vector<shared_ptr<AST::SymbolTable>> &sts = getSymbolTableStack(this);
        assert(!sts.empty());
        shared_ptr<AST::TypeType> type;
        if(sts.back()->exists(name))
        {
            AST::Symbol s = sts.back()->get(name);
            if(s.stype() != AST::Symbol::Type::Type)
                ::handleError(location, name + L" already defined");
            type = dynamic_pointer_cast<AST::TypeType>(s.value);
            if(type == nullptr)
                ::handleError(location, name + L" already defined");
        }
        else
        {
            type = AST::TypeType::make(location, name, AST::SymbolTable::make(), false);
            AST::Symbol s = AST::Symbol(name, AST::Symbol::Type::Type, type, type);
            sts.back()->make(s);
        }
        if(type->isComplete())
            ::handleError(location, name + L" already defined: " + static_cast<wstring>(type->location()));
        sts.push_back(type->symbols);
        $$ = ParserValueType(type);
    }
    ;

declaration: variableDeclaration {$$ = $1;}
    | typeStart typeDefinitionBlock End Type
    {
        shared_ptr<AST::TypeType> type = dynamic_pointer_cast<AST::TypeType>($1.node);
        type->isComplete(true);
        vector<shared_ptr<AST::SymbolTable>> &sts = getSymbolTableStack(this);
        assert(!sts.empty());
        sts.pop_back();
        $$ = ParserValueType(vector<shared_ptr<AST::Base>>{});
    }
    | Declare Type Id
    {
        wstring name = $3.token.svalue;
        Location location = $3.token.location;
        vector<shared_ptr<AST::SymbolTable>> &sts = getSymbolTableStack(this);
        assert(!sts.empty());
        shared_ptr<AST::TypeType> type;
        if(sts.back()->exists(name))
        {
            AST::Symbol s = sts.back()->get(name);
            if(s.stype() != AST::Symbol::Type::Type)
                ::handleError(location, name + L" already defined");
            type = dynamic_pointer_cast<AST::TypeType>(s.value);
            if(type == nullptr)
                ::handleError(location, name + L" already defined");
        }
        else
        {
            type = AST::TypeType::make(location, name, AST::SymbolTable::make(), false);
            AST::Symbol s = AST::Symbol(name, AST::Symbol::Type::Type, type, type);
            sts.back()->make(s);
        }
        $$ = ParserValueType(vector<shared_ptr<AST::Base>>{});
    }
    | procedureDefinition {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{});}
    | procedureDeclaration {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{});}
    ;

typeDefinitionBlock: {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{});}
    | typeDefinitionBlock typeDefinitionPartList newLine {$$ = $1; $$.nodes.insert($$.nodes.end(), $2.nodes.begin(), $2.nodes.end());}
    ;

typeDefinitionPartList: typeDefinitionPart {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{$1.node});}
    | typeDefinitionPartList ',' typeDefinitionPart {$$ = $1; $$.nodes.push_back($1.node);}
    ;

variableType: getLocation type
    {
        shared_ptr<const AST::Type> type = dynamic_pointer_cast<const AST::Type>($2.node);
        if(!type->isComplete())
            ::handleError($1.token.location, L"can't use incomplete type here");
        $$ = $2;
    }
    ;

procedureStart: Sub Id '(' fn_decl_arg_list ')'
    {
        wstring name = $2.token.svalue;
        Location location = $2.token.location;
        vector<shared_ptr<const AST::Type>> argTypes;
        vector<shared_ptr<AST::Base>> argNodes = $4.nodes;
        assert(argNodes.size() % 2 == 0);
        argTypes.reserve(argNodes.size() / 2);
        for(size_t i = 0; i < argNodes.size(); i += 2)
        {
            argTypes.push_back(dynamic_pointer_cast<const AST::Type>(argNodes[i + 1]));
        }
        shared_ptr<const AST::TypeProcedure> type = AST::TypeProcedure::make(location, AST::TypeProcedure::ProcedureType::Sub, argTypes, nullptr);
        vector<shared_ptr<AST::SymbolTable>> &sts = getSymbolTableStack(this);
        assert(!sts.empty());
        shared_ptr<AST::Procedure> procedure;
        if(sts.back()->exists(name))
        {
            AST::Symbol s = sts.back()->get(name);
            if(s.stype() != AST::Symbol::Type::Procedure)
                ::handleError(location, name + L" already defined");
            procedure = dynamic_pointer_cast<AST::Procedure>(s.value);
            if(*type != *procedure->type())
                ::handleError(location, name + L" doesn't match previous declaration: " + static_cast<wstring>(procedure->location()));
        }
        else
        {
            procedure = AST::Procedure::make(location, name, type, vector<shared_ptr<AST::Variable>>{}, nullptr, nullptr);
            AST::Symbol s = AST::Symbol(name, AST::Symbol::Type::Procedure, type, procedure);
            sts.back()->make(s);
        }
        if(procedure->code != nullptr)
            ::handleError(location, name + L" already defined: " + static_cast<wstring>(procedure->location()));
        procedure->argsRef().clear();
        procedure->argsRef().reserve(argTypes.size());
        sts.push_back(AST::SymbolTable::make());
        for(size_t i = 0; i < argNodes.size(); i += 2)
        {
            shared_ptr<AST::Variable> variable = dynamic_pointer_cast<AST::Variable>(argNodes[i]);
            procedure->argsRef().push_back(variable);
            if(variable != nullptr)
            {
                variable->containingProcedure(procedure);
                if(sts.back()->exists(variable->name()))
                    ::handleError(variable->location(), variable->name() + L" already defined");
                sts.back()->make(AST::Symbol(variable->name(), argTypes[i / 2]->isLValue() ? AST::Symbol::Type::ReferenceVariable : AST::Symbol::Type::AutoVariable, variable->type(), variable));
            }
        }
        $$ = ParserValueType(procedure);
        $$.token = $1.token;
        pushContainingProcedure(this, procedure);
        getDoStatementStack(this).push_back(nullptr);
        getForStatementStack(this).push_back(nullptr);
        getWhileStatementStack(this).push_back(nullptr);
    }
    | Function Id '(' fn_decl_arg_list ')' As variableType
    {
        wstring name = $2.token.svalue;
        Location location = $2.token.location;
        vector<shared_ptr<const AST::Type>> argTypes;
        vector<shared_ptr<AST::Base>> argNodes = $4.nodes;
        assert(argNodes.size() % 2 == 0);
        argTypes.reserve(argNodes.size() / 2);
        for(size_t i = 0; i < argNodes.size(); i += 2)
        {
            argTypes.push_back(dynamic_pointer_cast<const AST::Type>(argNodes[i + 1]));
        }
        shared_ptr<const AST::TypeProcedure> type = AST::TypeProcedure::make(location, AST::TypeProcedure::ProcedureType::Function, argTypes, dynamic_pointer_cast<const AST::Type>($7.node));
        vector<shared_ptr<AST::SymbolTable>> &sts = getSymbolTableStack(this);
        assert(!sts.empty());
        shared_ptr<AST::Procedure> procedure;
        if(sts.back()->exists(name))
        {
            AST::Symbol s = sts.back()->get(name);
            if(s.stype() != AST::Symbol::Type::Procedure)
                ::handleError(location, name + L" already defined");
            procedure = dynamic_pointer_cast<AST::Procedure>(s.value);
            if(*type != *procedure->type())
                ::handleError(location, name + L" doesn't match previous declaration: " + static_cast<wstring>(procedure->location()));
        }
        else
        {
            procedure = AST::Procedure::make(location, name, type, vector<shared_ptr<AST::Variable>>{}, nullptr, nullptr);
            AST::Symbol s = AST::Symbol(name, AST::Symbol::Type::Procedure, type, procedure);
            sts.back()->make(s);
        }
        if(procedure->code != nullptr)
            ::handleError(location, name + L" already defined: " + static_cast<wstring>(procedure->location()));
        procedure->argsRef().clear();
        procedure->argsRef().reserve(argTypes.size());
        sts.push_back(AST::SymbolTable::make());
        for(size_t i = 0; i < argNodes.size(); i += 2)
        {
            shared_ptr<AST::Variable> variable = dynamic_pointer_cast<AST::Variable>(argNodes[i]);
            procedure->argsRef().push_back(variable);
            if(variable != nullptr)
            {
                variable->containingProcedure(procedure);
                if(sts.back()->exists(variable->name()))
                    ::handleError(variable->location(), variable->name() + L" already defined");
                sts.back()->make(AST::Symbol(variable->name(), argTypes[i / 2]->isLValue() ? AST::Symbol::Type::ReferenceVariable : AST::Symbol::Type::AutoVariable, variable->type(), variable));
            }
        }
        if(procedure->type()->returnType->isLValue())
            ::handleError(location, L"can't create function that returns a ByRef type");
        procedure->returnValue = AST::AutoVariable::make(location, procedure, AST::TypeReference::toLValue(procedure->type()->returnType), AST::Variable::getReturnValueName(), nullptr);
        sts.back()->make(AST::Symbol(procedure->returnValue->name(), AST::Symbol::Type::AutoVariable, procedure->returnValue->type(), procedure->returnValue));
        $$ = ParserValueType(procedure);
        $$.token = $1.token;
        pushContainingProcedure(this, procedure);
        getDoStatementStack(this).push_back(nullptr);
        getForStatementStack(this).push_back(nullptr);
        getWhileStatementStack(this).push_back(nullptr);
    }
    ;

subOrFunction: Sub {$$ = $1;}
    | Function {$$ = $1;}
    ;

procedureDefinition: procedureStart codeBlockWithNewLine End subOrFunction
    {
        getSymbolTableStack(this).pop_back();
        shared_ptr<AST::Procedure> procedure = dynamic_pointer_cast<AST::Procedure>($1.node);
        procedure->code = dynamic_pointer_cast<AST::CodeBlock>($2.node);
        if($1.token.type != $4.token.type)
            ::handleError($4.token.location, L"expected: " + $1.token.svalue);
        popContainingProcedure(this);
        getDoStatementStack(this).pop_back();
        getForStatementStack(this).pop_back();
        getWhileStatementStack(this).pop_back();
    }
    ;

procedureDeclaration: Declare Sub Id '(' fn_decl_arg_list ')'
    {
        wstring name = $3.token.svalue;
        Location location = $3.token.location;
        vector<shared_ptr<const AST::Type>> argTypes;
        vector<shared_ptr<AST::Base>> argNodes = $5.nodes;
        assert(argNodes.size() % 2 == 0);
        argTypes.reserve(argNodes.size() / 2);
        for(size_t i = 0; i < argNodes.size(); i += 2)
        {
            argTypes.push_back(dynamic_pointer_cast<const AST::Type>(argNodes[i + 1]));
        }
        shared_ptr<const AST::TypeProcedure> type = AST::TypeProcedure::make(location, AST::TypeProcedure::ProcedureType::Sub, argTypes, nullptr);
        vector<shared_ptr<AST::SymbolTable>> &sts = getSymbolTableStack(this);
        assert(!sts.empty());
        if(sts.back()->exists(name))
        {
            AST::Symbol s = sts.back()->get(name);
            if(s.stype() != AST::Symbol::Type::Procedure)
                ::handleError(location, name + L" already defined");
            shared_ptr<AST::Procedure> procedure = dynamic_pointer_cast<AST::Procedure>(s.value);
            if(*type != *procedure->type())
                ::handleError(location, name + L" doesn't match previous declaration: " + static_cast<wstring>(procedure->location()));
        }
        else
        {
            shared_ptr<AST::Procedure> procedure = AST::Procedure::make(location, name, type, vector<shared_ptr<AST::Variable>>{}, nullptr, nullptr);
            AST::Symbol s = AST::Symbol(name, AST::Symbol::Type::Procedure, type, procedure);
            sts.back()->make(s);
        }
    }
    | Declare Function Id '(' fn_decl_arg_list ')' As variableType
    {
        wstring name = $3.token.svalue;
        Location location = $3.token.location;
        vector<shared_ptr<const AST::Type>> argTypes;
        vector<shared_ptr<AST::Base>> argNodes = $5.nodes;
        assert(argNodes.size() % 2 == 0);
        argTypes.reserve(argNodes.size() / 2);
        for(size_t i = 0; i < argNodes.size(); i += 2)
        {
            argTypes.push_back(dynamic_pointer_cast<const AST::Type>(argNodes[i + 1]));
        }
        shared_ptr<const AST::TypeProcedure> type = AST::TypeProcedure::make(location, AST::TypeProcedure::ProcedureType::Function, argTypes, dynamic_pointer_cast<const AST::Type>($8.node));
        vector<shared_ptr<AST::SymbolTable>> &sts = getSymbolTableStack(this);
        assert(!sts.empty());
        if(sts.back()->exists(name))
        {
            AST::Symbol s = sts.back()->get(name);
            if(s.stype() != AST::Symbol::Type::Procedure)
                ::handleError(location, name + L" already defined");
            shared_ptr<AST::Procedure> procedure = dynamic_pointer_cast<AST::Procedure>(s.value);
            if(*type != *procedure->type())
                ::handleError(location, name + L" doesn't match previous declaration: " + static_cast<wstring>(procedure->location()));
        }
        else
        {
            shared_ptr<AST::Procedure> procedure = AST::Procedure::make(location, name, type, vector<shared_ptr<AST::Variable>>{}, nullptr, nullptr);
            AST::Symbol s = AST::Symbol(name, AST::Symbol::Type::Procedure, type, procedure);
            sts.back()->make(s);
        }
    }
    ;

typeDefinitionPart: Id As variableType
    {
        shared_ptr<const AST::Type> type = dynamic_pointer_cast<const AST::Type>($3.node);
        wstring name = $1.token.svalue;
        Location location = $1.token.location;
        shared_ptr<AST::Variable> variable;
        AST::Symbol::Type stype;
        if(type->isLValue())
        {
            ::handleError(location, L"ByRef variable must have initializer");
        }
        else
        {
            type = AST::TypeReference::make(location, type);
            variable = AST::AutoVariable::make(location, nullptr, type, name, nullptr);
            stype = AST::Symbol::Type::AutoVariable;
        }
        vector<shared_ptr<AST::SymbolTable>> &sts = getSymbolTableStack(this);
        assert(!sts.empty());
        if(sts.back()->exists(name))
            ::handleError(location, name + L" already defined");
        sts.back()->make(AST::Symbol(name, stype, type, variable));
    }
    | procedureDefinition {$$ = $1;}
    ;

declarationPartList: declarationPart {$$ = $1;}
    | declarationPartList ',' declarationPart {$$ = $1; $$.nodes.insert($$.nodes.end(), $3.nodes.begin(), $3.nodes.end());}
    ;

declarationPart: declarationPartWithInitializer
    {
        $$ = ParserValueType(vector<shared_ptr<AST::Base>>{$1.node});
    }
    | Id As variableType
    {
        shared_ptr<const AST::Type> type = dynamic_pointer_cast<const AST::Type>($3.node);
        wstring name = $1.token.svalue;
        Location location = $1.token.location;
        shared_ptr<AST::Variable> variable;
        AST::Symbol::Type stype;
        if(type->isLValue())
        {
            ::handleError(location, L"ByRef variable must have initializer");
        }
        else
        {
            type = AST::TypeReference::make(location, type);
            variable = AST::AutoVariable::make(location, getContainingProcedure(this), type, name, nullptr);
            stype = AST::Symbol::Type::AutoVariable;
        }
        vector<shared_ptr<AST::SymbolTable>> &sts = getSymbolTableStack(this);
        assert(!sts.empty());
        if(sts.back()->exists(name))
            ::handleError(location, name + L" already defined");
        sts.back()->make(AST::Symbol(name, stype, type, variable));
        $$ = ParserValueType(vector<shared_ptr<AST::Base>>{AST::InitializeStatement::make(variable)});
    }
    ;

declarationPartWithInitializer: Id '=' expression
    {
        shared_ptr<AST::Expression> rhs = dynamic_pointer_cast<AST::Expression>($3.node);
        shared_ptr<const AST::Type> type = dynamic_pointer_cast<const AST::Type>(rhs->type()->toRValue());
        if(*type == *AST::TypeEmpty::getInstance())
            ::handleError($2.token.location, L"initializer has no type");
        wstring name = $1.token.svalue;
        Location location = $1.token.location;
        shared_ptr<AST::Variable> variable;
        AST::Symbol::Type stype;
        if(type->isLValue())
        {
            handleErrorNotImplemented(location, L"ByRef variable");
        }
        else
        {
            type = AST::TypeReference::make(location, type);
            variable = AST::AutoVariable::make(location, getContainingProcedure(this), type, name, rhs);
            stype = AST::Symbol::Type::AutoVariable;
        }
        vector<shared_ptr<AST::SymbolTable>> &sts = getSymbolTableStack(this);
        assert(!sts.empty());
        if(sts.back()->exists(name))
            ::handleError(location, name + L" already defined");
        sts.back()->make(AST::Symbol(name, stype, type, variable));
        $$ = ParserValueType(AST::InitializeStatement::make(variable));
    }
    | Id As variableType '=' expression
    {
        shared_ptr<const AST::Type> type = dynamic_pointer_cast<const AST::Type>($3.node);
        wstring name = $1.token.svalue;
        Location location = $1.token.location;
        shared_ptr<AST::Variable> variable;
        AST::Symbol::Type stype;
        if(type->isLValue())
        {
            type = AST::TypeReference::make(location, type);
            variable = AST::ReferenceVariable::make(location, getContainingProcedure(this), type, name, dynamic_pointer_cast<AST::Expression>($5.node));
            stype = AST::Symbol::Type::ReferenceVariable;
        }
        else
        {
            type = AST::TypeReference::make(location, type);
            variable = AST::AutoVariable::make(location, getContainingProcedure(this), type, name, dynamic_pointer_cast<AST::Expression>($5.node));
            stype = AST::Symbol::Type::AutoVariable;
        }
        vector<shared_ptr<AST::SymbolTable>> &sts = getSymbolTableStack(this);
        assert(!sts.empty());
        if(sts.back()->exists(name))
            ::handleError(location, name + L" already defined");
        sts.back()->make(AST::Symbol(name, stype, type, variable));
        $$ = ParserValueType(AST::InitializeStatement::make(variable));
    }
    ;

codeBlockWithNewLine: newLine codeBlock {$$ = $2;}
    ;

codeBlock: codeBlockInternal
    {
        shared_ptr<AST::SymbolTable> st = getSymbolTableStack(this).back();
        getSymbolTableStack(this).pop_back();
        vector<shared_ptr<AST::Statement>> statements;
        for(shared_ptr<AST::Base> n : $1.nodes)
            statements.push_back(dynamic_pointer_cast<AST::Statement>(n));
        $$ = ParserValueType(AST::CodeBlock::make($1.token.location, st, statements));
    }
    ;

codeBlockInternal: {getSymbolTableStack(this).push_back(AST::SymbolTable::make()); $$ = ParserValueType(vector<shared_ptr<AST::Base>>{}); $$.token.location = peekToken.token.location;}
    | codeBlockInternal statementList newLine {$$ = $1; $$.nodes.insert($$.nodes.end(), $2.nodes.begin(), $2.nodes.end());}
    | codeBlockInternal declaration newLine {$$ = $1; $$.nodes.insert($$.nodes.end(), $2.nodes.begin(), $2.nodes.end());}
    ;

statementList: statement {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{$1.node});}
    | restOfLineStatementList {$$ = $1;}
    ;

restOfLineStatementList: inlineStatementList {$$ = $1;}
    | inlineStatementList ':' restOfLineStatement {$$ = $1; $$.nodes.push_back($3.node);}
    | restOfLineStatement {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{$1.node});}
    ;

inlineStatementList: inlineStatement {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{$1.node});}
    | inlineStatementList ':' inlineStatement {$$ = $1; $$.nodes.push_back($3.node);}
    ;

doStatementStart: Do
    {
        $$ = $1;
        getDoStatementStack(this).push_back(AST::DoStatement::make($1.token.location, nullptr, AST::DoStatement::ConditionType::None, nullptr));
    }
    ;

whileStatementStart: While
    {
        $$ = $1;
        getWhileStatementStack(this).push_back(AST::WhileStatement::make($1.token.location, nullptr, nullptr));
    }
    ;

forStatementStart: For
    {
        $$ = $1;
        getForStatementStack(this).push_back(AST::ForStatement::make($1.token.location, nullptr, nullptr, nullptr, nullptr, nullptr, true));
    }
    ;

statement: ifStatement {$$ = $1;}
    | doStatementStart While expression codeBlockWithNewLine Loop
    {
        shared_ptr<AST::DoStatement> statement = getDoStatementStack(this).back();
        getDoStatementStack(this).pop_back();
        statement->setCondition(dynamic_pointer_cast<AST::Expression>($3.node), AST::DoStatement::ConditionType::DoWhile);
        statement->body = dynamic_pointer_cast<AST::CodeBlock>($4.node);
        $$ = ParserValueType(statement);
    }
    | doStatementStart Until expression codeBlockWithNewLine Loop
    {
        shared_ptr<AST::DoStatement> statement = getDoStatementStack(this).back();
        getDoStatementStack(this).pop_back();
        statement->setCondition(dynamic_pointer_cast<AST::Expression>($3.node), AST::DoStatement::ConditionType::DoUntil);
        statement->body = dynamic_pointer_cast<AST::CodeBlock>($4.node);
        $$ = ParserValueType(statement);
    }
    | doStatementStart codeBlockWithNewLine Loop While expression
    {
        shared_ptr<AST::DoStatement> statement = getDoStatementStack(this).back();
        getDoStatementStack(this).pop_back();
        statement->setCondition(dynamic_pointer_cast<AST::Expression>($5.node), AST::DoStatement::ConditionType::LoopWhile);
        statement->body = dynamic_pointer_cast<AST::CodeBlock>($2.node);
        $$ = ParserValueType(statement);
    }
    | doStatementStart codeBlockWithNewLine Loop Until expression
    {
        shared_ptr<AST::DoStatement> statement = getDoStatementStack(this).back();
        getDoStatementStack(this).pop_back();
        statement->setCondition(dynamic_pointer_cast<AST::Expression>($5.node), AST::DoStatement::ConditionType::LoopUntil);
        statement->body = dynamic_pointer_cast<AST::CodeBlock>($2.node);
        $$ = ParserValueType(statement);
    }
    | doStatementStart codeBlockWithNewLine Loop
    {
        shared_ptr<AST::DoStatement> statement = getDoStatementStack(this).back();
        getDoStatementStack(this).pop_back();
        statement->setCondition(nullptr, AST::DoStatement::ConditionType::None);
        statement->body = dynamic_pointer_cast<AST::CodeBlock>($2.node);
        $$ = ParserValueType(statement);
    }
    | whileStatementStart expression codeBlockWithNewLine WEnd
    {
        shared_ptr<AST::WhileStatement> statement = getWhileStatementStack(this).back();
        getWhileStatementStack(this).pop_back();
        statement->setCondition(dynamic_pointer_cast<AST::Expression>($2.node));
        statement->body = dynamic_pointer_cast<AST::CodeBlock>($2.node);
        $$ = ParserValueType(statement);
    }
    | forStatementStart expression_no_equals '=' expression To expression codeBlockWithNewLine Next
    {
        shared_ptr<AST::ForStatement> statement = getForStatementStack(this).back();
        getForStatementStack(this).pop_back();
        statement->variable = dynamic_pointer_cast<AST::Expression>($2.node);
        statement->start = dynamic_pointer_cast<AST::Expression>($4.node);
        statement->end = dynamic_pointer_cast<AST::Expression>($6.node);
        statement->step = nullptr;
        statement->body = dynamic_pointer_cast<AST::CodeBlock>($7.node);
        statement->calcTypes();
        $$ = ParserValueType(statement);
    }
    | forStatementStart expression_no_equals '=' expression To expression Step expression codeBlockWithNewLine Next
    {
        shared_ptr<AST::ForStatement> statement = getForStatementStack(this).back();
        getForStatementStack(this).pop_back();
        statement->variable = dynamic_pointer_cast<AST::Expression>($2.node);
        statement->start = dynamic_pointer_cast<AST::Expression>($4.node);
        statement->end = dynamic_pointer_cast<AST::Expression>($6.node);
        statement->step = dynamic_pointer_cast<AST::Expression>($8.node);
        statement->body = dynamic_pointer_cast<AST::CodeBlock>($9.node);
        statement->calcTypes();
        $$ = ParserValueType(statement);
    }
    | forDim declarationPartWithInitializer To expression codeBlockWithNewLine Next
    {
        shared_ptr<AST::InitializeStatement> initializer = dynamic_pointer_cast<AST::InitializeStatement>($2.node);
        shared_ptr<AST::Variable> variable = initializer->variable;
        shared_ptr<AST::Expression> start = variable->initializer();
        vector<shared_ptr<AST::SymbolTable>> &sts = getSymbolTableStack(this);
        assert(!sts.empty());
        shared_ptr<AST::ForStatement> statement = getForStatementStack(this).back();
        getForStatementStack(this).pop_back();
        statement->variable = variable;
        statement->start = start;
        statement->end = dynamic_pointer_cast<AST::Expression>($4.node);
        statement->step = nullptr;
        statement->body = dynamic_pointer_cast<AST::CodeBlock>($5.node);
        statement->calcTypes();
        shared_ptr<AST::CodeBlock> block = AST::CodeBlock::make($1.token.location, sts.back(), vector<shared_ptr<AST::Statement>>{statement});
        sts.pop_back();
        $$ = ParserValueType(block);
    }
    | forDim declarationPartWithInitializer To expression Step expression codeBlockWithNewLine Next
    {
        shared_ptr<AST::InitializeStatement> initializer = dynamic_pointer_cast<AST::InitializeStatement>($2.node);
        shared_ptr<AST::Variable> variable = initializer->variable;
        shared_ptr<AST::Expression> start = variable->initializer();
        vector<shared_ptr<AST::SymbolTable>> &sts = getSymbolTableStack(this);
        assert(!sts.empty());
        shared_ptr<AST::ForStatement> statement = getForStatementStack(this).back();
        getForStatementStack(this).pop_back();
        statement->variable = variable;
        statement->start = start;
        statement->end = dynamic_pointer_cast<AST::Expression>($4.node);
        statement->step = dynamic_pointer_cast<AST::Expression>($6.node);
        statement->body = dynamic_pointer_cast<AST::CodeBlock>($7.node);
        statement->calcTypes();
        shared_ptr<AST::CodeBlock> block = AST::CodeBlock::make($1.token.location, sts.back(), vector<shared_ptr<AST::Statement>>{statement});
        sts.pop_back();
        $$ = ParserValueType(block);
    }
    ;

forDim: forStatementStart Dim {$$ = $1; getSymbolTableStack(this).push_back(AST::SymbolTable::make());}
    ;

inlineStatement: expression_no_equals '=' expression
    {
        shared_ptr<AST::Procedure> procedure = getContainingProcedure(this);
        if($1.node == procedure && procedure->returnValue != nullptr)
        {
            $1.node = procedure->returnValue;
        }
        $$ = ParserValueType(AST::AssignStatement::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node)));
    }
    | Exit Do
    {
        auto &loopStack = getDoStatementStack(this);
        shared_ptr<AST::DoStatement> statement = nullptr;
        if(!loopStack.empty())
            statement = loopStack.back();
        if(statement == nullptr)
            ::handleError($1.token.location, L"Exit " + $2.token.svalue + L" not inside a " + $2.token.svalue + L" loop");
        $$ = ParserValueType(AST::ExitDoStatement::make($1.token.location, statement));
    }
    | Exit While
    {
        auto &loopStack = getWhileStatementStack(this);
        shared_ptr<AST::WhileStatement> statement = nullptr;
        if(!loopStack.empty())
            statement = loopStack.back();
        if(statement == nullptr)
            ::handleError($1.token.location, L"Exit " + $2.token.svalue + L" not inside a " + $2.token.svalue + L" loop");
        $$ = ParserValueType(AST::ExitWhileStatement::make($1.token.location, statement));
    }
    | Exit For
    {
        auto &loopStack = getForStatementStack(this);
        shared_ptr<AST::ForStatement> statement = nullptr;
        if(!loopStack.empty())
            statement = loopStack.back();
        if(statement == nullptr)
            ::handleError($1.token.location, L"Exit " + $2.token.svalue + L" not inside a " + $2.token.svalue + L" loop");
        $$ = ParserValueType(AST::ExitForStatement::make($1.token.location, statement));
    }
    | Exit subOrFunction
    {
        shared_ptr<AST::Procedure> procedure = getContainingProcedure(this);
        if(procedure == nullptr)
            ::handleError($1.token.location, L"Exit " + $2.token.svalue + L" not inside a " + $2.token.svalue + L" definition");
        TokenType ttype = TokenType::TTEOF;
        switch(procedure->type()->procedureType)
        {
        case AST::TypeProcedure::ProcedureType::Sub:
            ttype = TokenType::TTSub;
            break;
        case AST::TypeProcedure::ProcedureType::Function:
            ttype = TokenType::TTFunction;
            break;
        }
        assert(ttype != TokenType::TTEOF);
        if(ttype != $2.token.type)
            ::handleError($1.token.location, L"Exit " + $2.token.svalue + L" not inside a " + $2.token.svalue + L" definition");
        $$ = ParserValueType(AST::ExitProcedureStatement::make($1.token.location, procedure));
    }
    | expression_no_equals {$$ = $1;}
    ;

restOfLineStatement: If expression Then restOfLineStatementList {handleErrorNotImplemented($1.token);}
    | If expression Then inlineStatementList Else restOfLineStatementList {handleErrorNotImplemented($1.token);}
    ;

ifStatement: ifStatementInternal End If {$$ = $1; dynamic_pointer_cast<AST::IfStatement>($$.node)->checkTypes();}
    | ifStatementInternal Else codeBlockWithNewLine End If
    {
        $$ = $1;
        shared_ptr<AST::IfStatement> s = dynamic_pointer_cast<AST::IfStatement>($$.node);
        s->elseSection = dynamic_pointer_cast<AST::CodeBlock>($3.node);
        s->checkTypes();
    }
    ;

ifStatementInternal: If expression Then codeBlockWithNewLine
    {
        $$ = ParserValueType(AST::IfStatement::make($1.token.location,
                                                    vector<pair<shared_ptr<AST::Expression>, shared_ptr<AST::CodeBlock>>>(
                                                    {
                                                        pair<shared_ptr<AST::Expression>, shared_ptr<AST::CodeBlock>>(dynamic_pointer_cast<AST::Expression>($2.node), dynamic_pointer_cast<AST::CodeBlock>($4.node))
                                                    })));
    }
    | ifStatementInternal ElseIf expression Then codeBlockWithNewLine
    {
        $$ = $1;
        shared_ptr<AST::IfStatement> s = dynamic_pointer_cast<AST::IfStatement>($$.node);
        s->ifSections.push_back(pair<shared_ptr<AST::Expression>, shared_ptr<AST::CodeBlock>>(dynamic_pointer_cast<AST::Expression>($3.node), dynamic_pointer_cast<AST::CodeBlock>($5.node)));
    }
    ;

expression: or_expression {$$ = $1;}
    ;

expression_no_equals: or_expression_no_equals {$$ = $1;}
    ;

or_expression: xor_expression {$$ = $1;}
    | or_expression Or xor_expression {$$ = ParserValueType(AST::OrExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node)));}
    ;

or_expression_no_equals: xor_expression_no_equals {$$ = $1;}
    | or_expression_no_equals Or xor_expression_no_equals {$$ = ParserValueType(AST::OrExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node)));}
    ;

xor_expression: and_expression {$$ = $1;}
    | xor_expression Xor and_expression {$$ = ParserValueType(AST::XorExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node)));}
    ;

xor_expression_no_equals: and_expression_no_equals {$$ = $1;}
    | xor_expression_no_equals Xor and_expression_no_equals {$$ = ParserValueType(AST::XorExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node)));}
    ;

and_expression: not_expression {$$ = $1;}
    | and_expression And not_expression {$$ = ParserValueType(AST::AndExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node)));}
    ;

and_expression_no_equals: not_expression_no_equals {$$ = $1;}
    | and_expression_no_equals And not_expression_no_equals {$$ = ParserValueType(AST::AndExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node)));}
    ;

not_expression: compare_expression {$$ = $1;}
    | Not not_expression {$$ = ParserValueType(AST::NotExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($2.node)));}
    ;

not_expression_no_equals: compare_expression_no_equals {$$ = $1;}
    | Not not_expression_no_equals {$$ = ParserValueType(AST::NotExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($2.node)));}
    ;

compare_expression: add_expression {$$ = $1;}
    | compare_expression '<' add_expression
    {
        $$ = ParserValueType(AST::CompareExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), AST::CompareExpression::CType::LT, dynamic_pointer_cast<AST::Expression>($3.node)));
    }
    | compare_expression '>' add_expression
    {
        $$ = ParserValueType(AST::CompareExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), AST::CompareExpression::CType::GT, dynamic_pointer_cast<AST::Expression>($3.node)));
    }
    | compare_expression LogicalLE add_expression
    {
        $$ = ParserValueType(AST::CompareExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), AST::CompareExpression::CType::LE, dynamic_pointer_cast<AST::Expression>($3.node)));
    }
    | compare_expression LogicalGE add_expression
    {
        $$ = ParserValueType(AST::CompareExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), AST::CompareExpression::CType::GE, dynamic_pointer_cast<AST::Expression>($3.node)));
    }
    | compare_expression '=' add_expression
    {
        $$ = ParserValueType(AST::CompareExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), AST::CompareExpression::CType::Eq, dynamic_pointer_cast<AST::Expression>($3.node)));
    }
    | compare_expression LogicalNE add_expression
    {
        $$ = ParserValueType(AST::CompareExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), AST::CompareExpression::CType::NE, dynamic_pointer_cast<AST::Expression>($3.node)));
    }
    ;

compare_expression_no_equals: add_expression {$$ = $1;}
    | compare_expression_no_equals '<' add_expression
    {
        $$ = ParserValueType(AST::CompareExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), AST::CompareExpression::CType::LT, dynamic_pointer_cast<AST::Expression>($3.node)));
    }
    | compare_expression_no_equals '>' add_expression
    {
        $$ = ParserValueType(AST::CompareExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), AST::CompareExpression::CType::GT, dynamic_pointer_cast<AST::Expression>($3.node)));
    }
    | compare_expression_no_equals LogicalLE add_expression
    {
        $$ = ParserValueType(AST::CompareExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), AST::CompareExpression::CType::LE, dynamic_pointer_cast<AST::Expression>($3.node)));
    }
    | compare_expression_no_equals LogicalGE add_expression
    {
        $$ = ParserValueType(AST::CompareExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), AST::CompareExpression::CType::GE, dynamic_pointer_cast<AST::Expression>($3.node)));
    }
    | compare_expression_no_equals LogicalNE add_expression
    {
        $$ = ParserValueType(AST::CompareExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), AST::CompareExpression::CType::NE, dynamic_pointer_cast<AST::Expression>($3.node)));
    }
    ;

add_expression: mod_expression {$$ = $1;}
    | add_expression '+' mod_expression {$$ = ParserValueType(AST::AddExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node)));}
    | add_expression '-' mod_expression {$$ = ParserValueType(AST::SubExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node)));}
    ;

mod_expression: mul_expression {$$ = $1;}
    | mod_expression Mod mul_expression {$$ = ParserValueType(AST::ModExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node)));}
    | mod_expression '\\' mul_expression {$$ = ParserValueType(AST::IDivExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node)));}
    ;

mul_expression: neg_expression {$$ = $1;}
    | mul_expression '*' neg_expression {$$ = ParserValueType(AST::MulExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node)));}
    | mul_expression '/' neg_expression {$$ = ParserValueType(AST::FDivExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node)));}
    ;

neg_expression: toplevel_expression {$$ = $1;}
    | '-' neg_expression {$$ = ParserValueType(AST::NegExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($2.node)));}
    | '+' neg_expression {$$ = ParserValueType(AST::UnaryPlusExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($2.node)));}
    ;

toplevel_expression: StringLiteral {$$ = ParserValueType(AST::StringLiteralExpression::make($1.token.location, $1.token.svalue));}
    | IntegerLiteral {$$ = ParserValueType(AST::IntegerLiteralExpression::make($1.token.location, $1.token.svalue, ::handleError));}
    | SingleLiteral {$$ = ParserValueType(AST::SingleLiteralExpression::make($1.token.location, $1.token.getFloatingPointLiteralValue()));}
    | DoubleLiteral {$$ = ParserValueType(AST::DoubleLiteralExpression::make($1.token.location, $1.token.getFloatingPointLiteralValue()));}
    | True {$$ = ParserValueType(AST::BooleanLiteralExpression::make($1.token.location, true));}
    | False {$$ = ParserValueType(AST::BooleanLiteralExpression::make($1.token.location, false));}
    | '(' expression ')' {$$ = $2;}
    | Abs '(' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::Abs, dynamic_pointer_cast<AST::Expression>($3.node)));}
    | Asc '(' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::Asc, dynamic_pointer_cast<AST::Expression>($3.node)));}
    | ATn '(' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::ATn1, dynamic_pointer_cast<AST::Expression>($3.node)));}
    | ATn '(' expression ',' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::ATn2, dynamic_pointer_cast<AST::Expression>($3.node), dynamic_pointer_cast<AST::Expression>($5.node)));}
    | Chr '(' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::Chr, dynamic_pointer_cast<AST::Expression>($3.node)));}
    | Cos '(' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::Cos, dynamic_pointer_cast<AST::Expression>($3.node)));}
    | CBool '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeBoolean::getInstance(), false));}
    | CU8/*=CByte*/ '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeUInt8::getInstance(), false));}
    | CU16 '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeUInt16::getInstance(), false));}
    | CU32 '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeUInt32::getInstance(), false));}
    | CU64 '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeUInt64::getInstance(), false));}
    | CSng '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeSingle::getInstance(), false));}
    | CStr '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeString::getInstance(), false));}
    | CDbl '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeDouble::getInstance(), false));}
    | CInt '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeInteger::getInstance(), false));}
    | CI8 '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeInt8::getInstance(), false));}
    | CI16 '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeInt16::getInstance(), false));}
    | CI32 '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeInt32::getInstance(), false));}
    | CI64 '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeInt64::getInstance(), false));}
    | Cast '(' type ',' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($5.node), dynamic_pointer_cast<const AST::Type>($3.node), false));}
    | Exp '(' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::Exp, dynamic_pointer_cast<AST::Expression>($3.node)));}
    | Hex '(' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::Hex, dynamic_pointer_cast<AST::Expression>($3.node)));}
    | Id
    {
        const AST::Symbol &symbol = getSymbolGlobal(this, $1.token);
        switch(symbol.stype())
        {
        case AST::Symbol::Type::AutoVariable:
        case AST::Symbol::Type::ReferenceVariable:
        case AST::Symbol::Type::StaticVariable:
        {
            shared_ptr<AST::Variable> variable = dynamic_pointer_cast<AST::Variable>(symbol.value);
            if(variable->containingProcedure() != nullptr && variable->containingProcedure() != getContainingProcedure(this))
                ::handleError($1.token.location, L"can't access local variable from another procedure");
            break;
        }
        case AST::Symbol::Type::Procedure:
            break;
        default:
            ::handleError($1.token.location, $1.token.svalue + L" is not a variable or procedure");
        }
        $$ = ParserValueType(symbol.value);
    }
    | toplevel_expression '(' expression_list ')'
    {
        vector<shared_ptr<AST::Expression>> expression_list;
        expression_list.reserve($3.nodes.size());
        for(shared_ptr<AST::Base> e : $3.nodes)
        {
            expression_list.push_back(dynamic_pointer_cast<AST::Expression>(e));
        }
        if(dynamic_cast<const AST::TypeArray *>(dynamic_pointer_cast<AST::Expression>($1.node)->type()->getAbsoluteBaseType().get()) != nullptr)
        {
            $$ = ParserValueType(AST::ArrayIndexExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), expression_list));
        }
        else
        {
            $$ = ParserValueType(AST::CallExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), expression_list));
        }
    }
    | toplevel_expression '.' Id
    {
        $$ = ParserValueType(AST::MemberAccessExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), $3.token.svalue));
    }
    | InStr '(' expression ',' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::InStr2, dynamic_pointer_cast<AST::Expression>($3.node), dynamic_pointer_cast<AST::Expression>($5.node)));}
    | InStr '(' expression ',' expression ',' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::InStr3, dynamic_pointer_cast<AST::Expression>($3.node), dynamic_pointer_cast<AST::Expression>($5.node), dynamic_pointer_cast<AST::Expression>($7.node)));}
    | LBound '(' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::LBound1, dynamic_pointer_cast<AST::Expression>($3.node)));}
    | LBound '(' expression ',' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::LBound2, dynamic_pointer_cast<AST::Expression>($3.node), dynamic_pointer_cast<AST::Expression>($5.node)));}
    | LCase '(' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::LCase, dynamic_pointer_cast<AST::Expression>($3.node)));}
    | Left '(' expression ',' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::Left, dynamic_pointer_cast<AST::Expression>($3.node), dynamic_pointer_cast<AST::Expression>($5.node)));}
    | Len '(' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::Len, dynamic_pointer_cast<AST::Expression>($3.node)));}
    | Log '(' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::Log, dynamic_pointer_cast<AST::Expression>($3.node)));}
    | LTrim '(' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::LTrim, dynamic_pointer_cast<AST::Expression>($3.node)));}
    | Mid '(' expression ',' expression ',' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::Mid3, dynamic_pointer_cast<AST::Expression>($3.node), dynamic_pointer_cast<AST::Expression>($5.node), dynamic_pointer_cast<AST::Expression>($7.node)));}
    | Mid '(' expression ',' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::Mid2, dynamic_pointer_cast<AST::Expression>($3.node), dynamic_pointer_cast<AST::Expression>($5.node)));}
    | Oct '(' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::Oct, dynamic_pointer_cast<AST::Expression>($3.node)));}
    | Right '(' expression ',' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::Right, dynamic_pointer_cast<AST::Expression>($3.node), dynamic_pointer_cast<AST::Expression>($5.node)));}
    | RTrim '(' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::RTrim, dynamic_pointer_cast<AST::Expression>($3.node)));}
    | Sgn '(' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::Sgn, dynamic_pointer_cast<AST::Expression>($3.node)));}
    | Sin '(' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::Sin, dynamic_pointer_cast<AST::Expression>($3.node)));}
    | Space '(' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::Space, dynamic_pointer_cast<AST::Expression>($3.node)));}
    | Sqr '(' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::Sqr, dynamic_pointer_cast<AST::Expression>($3.node)));}
    | Str '(' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::Str, dynamic_pointer_cast<AST::Expression>($3.node)));}
    | String '(' expression ',' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::String, dynamic_pointer_cast<AST::Expression>($3.node), dynamic_pointer_cast<AST::Expression>($5.node)));}
    | Tan '(' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::Tan, dynamic_pointer_cast<AST::Expression>($3.node)));}
    | UBound '(' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::UBound1, dynamic_pointer_cast<AST::Expression>($3.node)));}
    | UBound '(' expression ',' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::UBound2, dynamic_pointer_cast<AST::Expression>($3.node), dynamic_pointer_cast<AST::Expression>($5.node)));}
    | UCase '(' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::UCase, dynamic_pointer_cast<AST::Expression>($3.node)));}
    | Val '(' expression ')' {$$ = ParserValueType(AST::BuiltInFunctionExpression::make($1.token.location, AST::BuiltInFunctionExpression::FnType::Val, dynamic_pointer_cast<AST::Expression>($3.node)));}
    ;

expression_list: {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{});}
    | expression_list_non_empty {$$ = $1;}
    ;

expression_list_non_empty: expression {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{$1.node});}
    | expression_list_non_empty ',' expression {$$ = $1; $$.nodes.push_back($3.node);}
    ;

fn_decl_arg_list: {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{});}
    | fn_decl_arg_list_non_empty {$$ = $1;}
    ;

fn_decl_arg_list_non_empty: fn_decl_arg
    {
        $$ = $1;
    }
    | fn_decl_arg_list_non_empty ',' fn_decl_arg
    {
        $$ = $1;
        $$.nodes.insert($$.nodes.end(), $3.nodes.begin(), $3.nodes.end());
    }
    ;

fn_decl_arg: Id As variableType
    {
        shared_ptr<const AST::Type> argType = dynamic_pointer_cast<const AST::Type>($3.node);
        shared_ptr<AST::Variable> variable;
        if(argType->isLValue())
        {
            variable = AST::ReferenceVariable::make($1.token.location, nullptr, argType, $1.token.svalue, nullptr, true);
        }
        else
        {
            variable = AST::AutoVariable::make($1.token.location, nullptr, AST::TypeReference::toLValue(argType), $1.token.svalue, nullptr, true);
        }
        $$ = ParserValueType(vector<shared_ptr<const AST::Base>>{variable, argType});
    }
    | As variableType
    {
        $$ = ParserValueType(vector<shared_ptr<AST::Base>>{nullptr, $2.node});
    }
    ;

fn_type_arg_list: {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{});}
    | fn_type_arg_list_non_empty {$$ = $1;}
    ;

fn_type_arg_list_non_empty: Id As variableType {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{$3.node});}
    | As variableType {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{$2.node});}
    | fn_type_arg_list_non_empty ',' Id As variableType {$$ = $1; $$.nodes.push_back($5.node);}
    | fn_type_arg_list_non_empty ',' As variableType {$$ = $1; $$.nodes.push_back($4.node);}
    ;

type: Boolean {$$ = ParserValueType(AST::TypeBoolean::getInstance());}
    | Double {$$ = ParserValueType(AST::TypeDouble::getInstance());}
    | Integer {$$ = ParserValueType(AST::TypeInteger::getInstance());}
    | Int8  {$$ = ParserValueType(AST::TypeInt8::getInstance());}
    | Int16  {$$ = ParserValueType(AST::TypeInt16::getInstance());}
    | Int32  {$$ = ParserValueType(AST::TypeInt32::getInstance());}
    | Int64  {$$ = ParserValueType(AST::TypeInt64::getInstance());}
    | Single  {$$ = ParserValueType(AST::TypeSingle::getInstance());}
    | String  {$$ = ParserValueType(AST::TypeString::getInstance());}
    | UInt8/*= Byte*/  {$$ = ParserValueType(AST::TypeUInt8::getInstance());}
    | UInt16  {$$ = ParserValueType(AST::TypeUInt16::getInstance());}
    | UInt32  {$$ = ParserValueType(AST::TypeUInt32::getInstance());}
    | UInt64  {$$ = ParserValueType(AST::TypeUInt64::getInstance());}
    | ByRef type {$$ = ParserValueType(AST::TypeReference::make($1.token.location, dynamic_pointer_cast<const AST::Type>($2.node)->toRValue()));}
    | ByVal type {$$ = ParserValueType(dynamic_pointer_cast<const AST::Type>($2.node)->toRValue());}
    | Array '(' arrayIndexRanges ')' Of type
    {
        shared_ptr<AST::TypeArray> ta = dynamic_pointer_cast<AST::TypeArray>($3.node);
        $$ = ParserValueType(AST::TypeArray::make($1.token.location, dynamic_pointer_cast<const AST::Type>($6.node), ta->indexRanges()));
    }
    | Array Of variableType
    {
        $$ = ParserValueType(AST::TypeArray::make($1.token.location, dynamic_pointer_cast<const AST::Type>($3.node), vector<AST::TypeArray::IndexRange>{AST::TypeArray::defaultEmptyRange}));
    }
    | Function '(' fn_type_arg_list ')' As variableType
    {
        vector<shared_ptr<const AST::Type>> args;
        args.reserve($3.nodes.size());
        for(auto arg : $3.nodes)
        {
            args.push_back(dynamic_pointer_cast<const AST::Type>(arg));
        }
        $$ = ParserValueType(AST::TypeProcedure::make($1.token.location, AST::TypeProcedure::ProcedureType::Function, args, dynamic_pointer_cast<const AST::Type>($6.node)));
    }
    | Sub '(' fn_type_arg_list ')'
    {
        vector<shared_ptr<const AST::Type>> args;
        args.reserve($3.nodes.size());
        for(auto arg : $3.nodes)
        {
            args.push_back(dynamic_pointer_cast<const AST::Type>(arg));
        }
        $$ = ParserValueType(AST::TypeProcedure::make($1.token.location, AST::TypeProcedure::ProcedureType::Sub, args, nullptr));
    }
    | TypeOf '(' expression ')'
    {
        shared_ptr<const AST::Type> type = dynamic_pointer_cast<AST::Expression>($3.node)->type()->toRValue();
        if(*type == *AST::TypeEmpty::getInstance())
            ::handleError($1.token.location, L"TypeOf argument has no type");
        $$ = ParserValueType(type);
    }
    | Id {const AST::Symbol &symbol = getSymbolGlobal(this, $1.token); if(symbol.stype() != AST::Symbol::Type::Type) ::handleError($1.token.location, $1.token.svalue + L" is not a type"); $$ = ParserValueType(symbol.value);}
    ;

signedIntegerLiteral: IntegerLiteral
    {
        $$ = ParserValueType(AST::IntegerLiteralExpression::make($1.token.location, $1.token.svalue, ::handleError));
    }
    | '+' IntegerLiteral
    {
        $$ = ParserValueType(AST::IntegerLiteralExpression::make($1.token.location, $1.token.svalue, ::handleError));
    }
    | '-' IntegerLiteral
    {
        $$ = ParserValueType(AST::IntegerLiteralExpression::make($1.token.location, L"-" + $2.token.svalue, ::handleError));
    }
    ;

arrayIndexRanges:
    {
        $$ = ParserValueType(AST::TypeArray::make(peekToken.token.location, AST::TypeInteger::getInstance(), vector<AST::TypeArray::IndexRange>{AST::TypeArray::defaultEmptyRange}));
    }
    | signedIntegerLiteral
    {
        int64_t end, start = AST::TypeArray::defaultRangeStart;
        shared_ptr<AST::IntegerLiteralExpression> endNode = dynamic_pointer_cast<AST::IntegerLiteralExpression>($1.node);
        AST::CastExpression::checkCast(endNode->location(), endNode, AST::TypeInteger::getInstance(), true);
        end = endNode->value;
        AST::TypeArray::IndexRange ir = AST::TypeArray::IndexRange(start, end);
        if(AST::TypeArray::getRangeSize(ir) < 0)
            throw ParserError(endNode->location(), L"invalid range : size is less than zero");
        $$ = ParserValueType(AST::TypeArray::make($1.token.location, AST::TypeInteger::getInstance(), vector<AST::TypeArray::IndexRange>{ir}));
    }
    | signedIntegerLiteral To signedIntegerLiteral
    {
        int64_t start, end;
        shared_ptr<AST::IntegerLiteralExpression> startNode = dynamic_pointer_cast<AST::IntegerLiteralExpression>($1.node);
        AST::CastExpression::checkCast(startNode->location(), startNode, AST::TypeInteger::getInstance(), true);
        start = startNode->value;
        shared_ptr<AST::IntegerLiteralExpression> endNode = dynamic_pointer_cast<AST::IntegerLiteralExpression>($3.node);
        AST::CastExpression::checkCast(endNode->location(), endNode, AST::TypeInteger::getInstance(), true);
        end = endNode->value;
        AST::TypeArray::IndexRange ir = AST::TypeArray::IndexRange(start, end);
        if(AST::TypeArray::getRangeSize(ir) < 0)
            throw ParserError($2.token.location, L"invalid range : size is less than zero");
        $$ = ParserValueType(AST::TypeArray::make($1.token.location, AST::TypeInteger::getInstance(), vector<AST::TypeArray::IndexRange>{AST::TypeArray::IndexRange(start, end)}));
    }
    | arrayIndexRanges ','
    {
        $$ = $1;
        shared_ptr<AST::TypeArray> ta = dynamic_pointer_cast<AST::TypeArray>($$.node);
        vector<AST::TypeArray::IndexRange> indexRanges = ta->indexRanges();
        indexRanges.push_back(AST::TypeArray::defaultEmptyRange);
        $$ = ParserValueType(AST::TypeArray::make(ta->location(), AST::TypeInteger::getInstance(), indexRanges));
    }
    | arrayIndexRanges ',' signedIntegerLiteral
    {
        int64_t end, start = AST::TypeArray::defaultRangeStart;
        shared_ptr<AST::IntegerLiteralExpression> endNode = dynamic_pointer_cast<AST::IntegerLiteralExpression>($3.node);
        AST::CastExpression::checkCast(endNode->location(), endNode, AST::TypeInteger::getInstance(), true);
        end = endNode->value;
        AST::TypeArray::IndexRange ir = AST::TypeArray::IndexRange(start, end);
        if(AST::TypeArray::getRangeSize(ir) < 0)
            throw ParserError(endNode->location(), L"invalid range : size is less than zero");
        $$ = $1;
        shared_ptr<AST::TypeArray> ta = dynamic_pointer_cast<AST::TypeArray>($$.node);
        vector<AST::TypeArray::IndexRange> indexRanges = ta->indexRanges();
        indexRanges.push_back(ir);
        $$ = ParserValueType(AST::TypeArray::make(ta->location(), AST::TypeInteger::getInstance(), indexRanges));
    }
    | arrayIndexRanges ',' signedIntegerLiteral To signedIntegerLiteral
    {
        int64_t start, end;
        shared_ptr<AST::IntegerLiteralExpression> startNode = dynamic_pointer_cast<AST::IntegerLiteralExpression>($3.node);
        AST::CastExpression::checkCast(startNode->location(), startNode, AST::TypeInteger::getInstance(), true);
        start = startNode->value;
        shared_ptr<AST::IntegerLiteralExpression> endNode = dynamic_pointer_cast<AST::IntegerLiteralExpression>($5.node);
        AST::CastExpression::checkCast(endNode->location(), endNode, AST::TypeInteger::getInstance(), true);
        end = endNode->value;
        AST::TypeArray::IndexRange ir = AST::TypeArray::IndexRange(start, end);
        if(AST::TypeArray::getRangeSize(ir) < 0)
            throw ParserError($4.token.location, L"invalid range : size is less than zero");
        $$ = $1;
        shared_ptr<AST::TypeArray> ta = dynamic_pointer_cast<AST::TypeArray>($$.node);
        vector<AST::TypeArray::IndexRange> indexRanges = ta->indexRanges();
        indexRanges.push_back(ir);
        $$ = ParserValueType(AST::TypeArray::make(ta->location(), AST::TypeInteger::getInstance(), indexRanges));
    }
    ;

newLine: '\n' {$$ = $1;}
    | newLine '\n' {$$ = $1;}
    ;
%%
%{
#include <cwctype>
#include <cassert>
#include <sstream>
#include "string_cast.h"

using namespace std;

class Parser : public ParserBase
{
    Tokenizer tokenizer;
public:
    explicit Parser(shared_ptr<InputStream> is)
        : tokenizer(is)
    {
    }
    vector<shared_ptr<AST::SymbolTable>> symbolTableStack;
    Location lastTokenLocation;
    vector<shared_ptr<AST::Procedure>> procedureStack;
    vector<shared_ptr<AST::DoStatement>> doStatementStack;
    vector<shared_ptr<AST::ForStatement>> forStatementStack;
    vector<shared_ptr<AST::WhileStatement>> whileStatementStack;
protected:
    virtual ParserValueType getToken() override
    {
        Token token = tokenizer.getToken();
        lastTokenLocation = token.location;
        return ParserValueType(token);
    }
};

vector<shared_ptr<AST::SymbolTable>> &getSymbolTableStack(ParserBase *parser)
{
    Parser *theParser = dynamic_cast<Parser *>(parser);
    assert(theParser != nullptr);
    return theParser->symbolTableStack;
}

shared_ptr<AST::CodeBlock> parseAll(shared_ptr<InputStream> is)
{
    Parser parser(is);
    try
    {
        return dynamic_pointer_cast<AST::CodeBlock>(parser.parse().node);
    }
    catch(ParserBase::ParseError &e)
    {
        throw ParserError(parser.lastTokenLocation, string_cast<wstring>(e.what()));
    }
}

shared_ptr<AST::Procedure> getContainingProcedure(ParserBase *parser)
{
    Parser *theParser = dynamic_cast<Parser *>(parser);
    assert(theParser != nullptr);
    if(theParser->procedureStack.empty())
        return nullptr;
    return theParser->procedureStack.back();
}

void pushContainingProcedure(ParserBase *parser, shared_ptr<AST::Procedure> procedure)
{
    Parser *theParser = dynamic_cast<Parser *>(parser);
    assert(theParser != nullptr);
    theParser->procedureStack.push_back(procedure);
}

void popContainingProcedure(ParserBase *parser)
{
    Parser *theParser = dynamic_cast<Parser *>(parser);
    assert(theParser != nullptr);
    assert(!theParser->procedureStack.empty());
    theParser->procedureStack.pop_back();
}

vector<shared_ptr<AST::DoStatement>> &getDoStatementStack(ParserBase *parser)
{
    Parser *theParser = dynamic_cast<Parser *>(parser);
    assert(theParser != nullptr);
    return theParser->doStatementStack;
}

vector<shared_ptr<AST::ForStatement>> &getForStatementStack(ParserBase *parser)
{
    Parser *theParser = dynamic_cast<Parser *>(parser);
    assert(theParser != nullptr);
    return theParser->forStatementStack;
}

vector<shared_ptr<AST::WhileStatement>> &getWhileStatementStack(ParserBase *parser)
{
    Parser *theParser = dynamic_cast<Parser *>(parser);
    assert(theParser != nullptr);
    return theParser->whileStatementStack;
}

%}
