%{
#include <cstdint>
#include <cwchar>
#include <string>
#include <memory>
#include <iostream>
#include <vector>
#include "tokenizer.h"
#include "ast/all.h"

using namespace std;

struct ParserValueType final
{
    Token token;
    shared_ptr<AST::Base> node;
    vector<shared_ptr<AST::Base>> nodes; // for lists
    explicit ParserValueType(TokenType tokenType = TokenType::TTEOF)
        : token(tokenType), node(nullptr)
    {
    }
    explicit ParserValueType(char tokenType)
        : token((TokenType)tokenType), node(nullptr)
    {
    }
    explicit ParserValueType(Token token)
        : token(token), node(nullptr)
    {
    }
    explicit ParserValueType(shared_ptr<const AST::Base> node)
        : token(), node(const_pointer_cast<AST::Base>(node))
    {
    }
    explicit ParserValueType(vector<shared_ptr<AST::Base>> nodes)
        : token(), node(nullptr), nodes(nodes)
    {
    }
    bool operator ==(const ParserValueType &rt) const
    {
        return token.type == rt.token.type && node == rt.node;
    }
    bool operator !=(const ParserValueType &rt) const
    {
        return token.type != rt.token.type || node != rt.node;
    }
};

class ParserBase;

vector<AST::SymbolTable> &getSymbolTableStack(ParserBase *parser);

inline bool symbolExistsGlobal(ParserBase *parser, const wstring &name)
{
    vector<AST::SymbolTable> &sts = getSymbolTableStack(parser);
    for(auto i = sts.rbegin(); i != sts.rend(); ++i)
    {
        if(i->exists(name))
            return true;
    }
    return false;
}

void handleError(ParserBase *parser, Location location, const wstring &msg);
inline void handleErrorNotImplemented(ParserBase *parser, Location location, const wstring &what)
{
    handleError(parser, location, what + L" not implemented");
}

inline void handleErrorNotImplemented(ParserBase *parser, Token t)
{
    handleErrorNotImplemented(parser, t.location, t.svalue);
}

inline const AST::Symbol &getSymbolGlobal(ParserBase *parser, Location location, const wstring &name)
{
    vector<AST::SymbolTable> &sts = getSymbolTableStack(parser);
    for(auto i = sts.rbegin(); i != sts.rend(); ++i)
    {
        if(i->exists(name))
            return i->get(name);
    }
    handleError(parser, location, L"undeclared identifier : " + name);
    throw logic_error("shouldn't be here");
}

inline const AST::Symbol &getSymbolGlobal(ParserBase *parser, Token t)
{
    return getSymbolGlobal(parser, t.location, t.svalue);
}

ParserValueType parseAll(shared_ptr<InputStream> is);

%}
%option SymbolPrefix "TokenType::TT"
%option ValueType "ParserValueType"
%option "UseC++11"
%option "ClassName" "ParserBase"
%token Id
%token StringLiteral
%token IntegerLiteral
%token SingleLiteral
%token DoubleLiteral
%token LogicalGE
%token LogicalLE
%token LogicalNE
%token Abs
%token And
%token As
%token Asc
%token ATn
%token Boolean
%token ByRef
%token ByVal
%token Case
%token Cast
%token CBool
%token CDouble
%token CInt
%token CI8
%token CI16
%token CI32
%token CI64
%token CPtr
%token CSng
%token CStr
%token CU8
//%token CByte
%token CU16
%token CU32
%token CU64
%token Chr
%token Cos
%token Dim
%token Declare
%token Do
%token Double
%token Else
%token ElseIf
%token End
%token Exit
%token Exp
%token False
%token For
%token Function
%token Hex
%token If
%token InStr
%token Int
%token Integer
%token Int8
%token Int16
%token Int32
%token Int64
%token Is
%token LBound
%token LCase
%token Left
%token Len
%token Log
%token Loop
%token LTrim
%token Mid
%token Mod
%token Not
%token Oct
%token Or
%token Pointer
%token Right
%token RTrim
%token Select
%token Sgn
%token Sin
%token Single
%token Space
%token Sqr
%token Static
%token Step
%token Str
%token String
%token Sub
%token Tan
%token Then
%token To
%token True
%token Type
%token TypeOf
%token UBound
%token UCase
%token UInt8
//%token Byte
%token UInt16
%token UInt32
%token UInt64
%token Until
%token Val
%token WEnd
%token While
%token Xor
%%

program: {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{});}
    | newLine {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{});}
    | program declaration newLine {$$ = $1; $$.nodes.insert($$.nodes.end(), $2.nodes.begin(), $2.nodes.end());}
    | program statementList newLine {$$ = $1; $$.nodes.insert($$.nodes.end(), $2.nodes.begin(), $2.nodes.end());}
    ;

variableDeclaration: Dim {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{});}
    | Dim declarationPartList {$$ = $2;}
    ;

declaration: variableDeclaration {$$ = $1;}
    | Type Id newLine typeDefinitionBlock End Type {handleErrorNotImplemented(this, $1.token);}
    | procedureDefinition {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{$1.node});}
    | procedureDeclaration {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{$1.node});}
    ;

typeDefinitionBlock: {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{});}
    | typeDefinitionPartList newLine {$$ = $1;}
    ;

typeDefinitionPartList: typeDefinitionPart {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{$1.node});}
    | typeDefinitionPartList ',' typeDefinitionPart {$$ = $1; $$.nodes.push_back($1.node);}
    ;

procedureDefinition: Sub Id '(' fn_decl_arg_list ')' codeBlockWithNewLine End Sub {handleErrorNotImplemented(this, $1.token);}
    | Function Id '(' fn_decl_arg_list ')' As type codeBlockWithNewLine End Function {handleErrorNotImplemented(this, $1.token);}
    ;

procedureDeclaration: Declare Sub Id '(' fn_decl_arg_list ')' {handleErrorNotImplemented(this, $1.token.location, L"Declare Sub");}
    | Declare Function Id '(' fn_decl_arg_list ')' As type {handleErrorNotImplemented(this, $1.token.location, L"Declare Function");}
    ;

typeDefinitionPart: Id As type {handleErrorNotImplemented(this, $1.token.location, L"Type");}
    | procedureDefinition {$$ = $1;}
    ;

declarationPartList: declarationPart {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{$1.node});}
    | declarationPartList ',' declarationPart {$$ = $1; $$.nodes.push_back($3.node);}
    ;

declarationPart: Id {handleErrorNotImplemented(this, $1.token.location, L"Dim");}
    | Id '=' expression {handleErrorNotImplemented(this, $1.token.location, L"Dim");}
    | Id As type {handleErrorNotImplemented(this, $1.token.location, L"Dim");}
    | Id As type '=' expression {handleErrorNotImplemented(this, $1.token.location, L"Dim");}
    ;

codeBlockWithNewLine: newLine {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{});}
    | codeBlockWithNewLine statementList newLine {$$ = $1; $$.nodes.insert($$.nodes.end(), $2.nodes.begin(), $2.nodes.end());}
    | codeBlockWithNewLine variableDeclaration newLine {$$ = $1; $$.nodes.insert($$.nodes.end(), $2.nodes.begin(), $2.nodes.end());}
    ;

statementList: statement {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{$1.node});}
    | restOfLineStatementList {$$ = $1;}
    ;

restOfLineStatementList: inlineStatementList {$$ = $1;}
    | inlineStatementList ':' restOfLineStatement {$$ = $1; $$.nodes.push_back($3.node);}
    | restOfLineStatement {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{$1.node});}
    ;

inlineStatementList: inlineStatement {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{$1.node});}
    | inlineStatementList ':' inlineStatement {$$ = $1; $$.nodes.push_back($3.node);}
    ;

statement: If expression Then codeBlockWithNewLine elseSection End If {handleErrorNotImplemented(this, $1.token);}
    | Do While expression codeBlockWithNewLine Loop {handleErrorNotImplemented(this, $1.token);}
    | Do Until expression codeBlockWithNewLine Loop {handleErrorNotImplemented(this, $1.token);}
    | Do codeBlockWithNewLine Loop While expression {handleErrorNotImplemented(this, $1.token);}
    | Do codeBlockWithNewLine Loop Until expression {handleErrorNotImplemented(this, $1.token);}
    | Do codeBlockWithNewLine Loop {handleErrorNotImplemented(this, $1.token);}
    | While expression codeBlockWithNewLine WEnd {handleErrorNotImplemented(this, $1.token);}
    | For variable '=' expression To expression codeBlockWithNewLine Next {handleErrorNotImplemented(this, $1.token);}
    | For variable '=' expression To expression Step expression codeBlockWithNewLine Next {handleErrorNotImplemented(this, $1.token);}
    | For Dim Id '=' expression To expression codeBlockWithNewLine Next {handleErrorNotImplemented(this, $1.token);}
    | For Dim Id '=' expression To expression Step expression codeBlockWithNewLine Next {handleErrorNotImplemented(this, $1.token);}
    ;

inlineStatement: expression_no_equals '=' expression {handleErrorNotImplemented(this, $2.token.location, L"assignment");}
    | Exit Do {handleErrorNotImplemented(this, $1.token.location, L"Exit Do");}
    | Exit While {handleErrorNotImplemented(this, $1.token.location, L"Exit While");}
    | Exit For {handleErrorNotImplemented(this, $1.token.location, L"Exit For");}
    | Exit Sub {handleErrorNotImplemented(this, $1.token.location, L"Exit Sub");}
    | Exit Function {handleErrorNotImplemented(this, $1.token.location, L"Exit Function");}
    | expression_no_equals {$$ = $1; wcout << L"debug: expression type = " << dynamic_cast<AST::Expression &>(*$1.node).type()->toString() << endl;}
    ;

restOfLineStatement: If expression Then restOfLineStatementList {handleErrorNotImplemented(this, $1.token);}
    | If expression Then inlineStatementList Else restOfLineStatementList {handleErrorNotImplemented(this, $1.token);}
    ;

elseSection:
    | Else codeBlockWithNewLine {handleErrorNotImplemented(this, $1.token);}
    | ElseIf expression Then codeBlockWithNewLine elseSection {handleErrorNotImplemented(this, $1.token);}
    ;

expression: or_expression {$$ = $1;}
    ;

expression_no_equals: or_expression_no_equals {$$ = $1;}
    ;

or_expression: xor_expression {$$ = $1;}
    | or_expression Or xor_expression {$$ = ParserValueType(AST::OrExpression::make(dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node), [&](const wstring &msg){::handleError(this, $2.token.location, msg);}));}
    ;

or_expression_no_equals: xor_expression_no_equals {$$ = $1;}
    | or_expression_no_equals Or xor_expression_no_equals {$$ = ParserValueType(AST::OrExpression::make(dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node), [&](const wstring &msg){::handleError(this, $2.token.location, msg);}));}
    ;

xor_expression: and_expression {$$ = $1;}
    | xor_expression Xor and_expression {$$ = ParserValueType(AST::XorExpression::make(dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node), [&](const wstring &msg){::handleError(this, $2.token.location, msg);}));}
    ;

xor_expression_no_equals: and_expression_no_equals {$$ = $1;}
    | xor_expression_no_equals Xor and_expression_no_equals {$$ = ParserValueType(AST::XorExpression::make(dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node), [&](const wstring &msg){::handleError(this, $2.token.location, msg);}));}
    ;

and_expression: not_expression {$$ = $1;}
    | and_expression And not_expression {$$ = ParserValueType(AST::AndExpression::make(dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node), [&](const wstring &msg){::handleError(this, $2.token.location, msg);}));}
    ;

and_expression_no_equals: not_expression_no_equals {$$ = $1;}
    | and_expression_no_equals And not_expression_no_equals {$$ = ParserValueType(AST::AndExpression::make(dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node), [&](const wstring &msg){::handleError(this, $2.token.location, msg);}));}
    ;

not_expression: compare_expression {$$ = $1;}
    | Not not_expression {handleErrorNotImplemented(this, $1.token);}
    ;

not_expression_no_equals: compare_expression_no_equals {$$ = $1;}
    | Not not_expression_no_equals {handleErrorNotImplemented(this, $1.token);}
    ;

compare_expression: add_expression {$$ = $1;}
    | compare_expression '<' add_expression {handleErrorNotImplemented(this, $2.token);}
    | compare_expression '>' add_expression {handleErrorNotImplemented(this, $2.token);}
    | compare_expression LogicalLE add_expression {handleErrorNotImplemented(this, $2.token);}
    | compare_expression LogicalGE add_expression {handleErrorNotImplemented(this, $2.token);}
    | compare_expression '=' add_expression {handleErrorNotImplemented(this, $2.token);}
    | compare_expression LogicalNE add_expression {handleErrorNotImplemented(this, $2.token);}
    ;

compare_expression_no_equals: add_expression {$$ = $1;}
    | compare_expression_no_equals '<' add_expression {handleErrorNotImplemented(this, $2.token);}
    | compare_expression_no_equals '>' add_expression {handleErrorNotImplemented(this, $2.token);}
    | compare_expression_no_equals LogicalLE add_expression {handleErrorNotImplemented(this, $2.token);}
    | compare_expression_no_equals LogicalGE add_expression {handleErrorNotImplemented(this, $2.token);}
    | compare_expression_no_equals LogicalNE add_expression {handleErrorNotImplemented(this, $2.token);}
    ;

add_expression: mod_expression {$$ = $1;}
    | add_expression '+' mod_expression {handleErrorNotImplemented(this, $2.token.location, L"binary +");}
    | add_expression '-' mod_expression {handleErrorNotImplemented(this, $2.token.location, L"binary -");}
    ;

mod_expression: mul_expression {$$ = $1;}
    | mod_expression Mod mul_expression {handleErrorNotImplemented(this, $2.token);}
    | mod_expression '\\' mul_expression {handleErrorNotImplemented(this, $2.token);}
    ;

mul_expression: neg_expression {$$ = $1;}
    | mul_expression '*' neg_expression {handleErrorNotImplemented(this, $2.token);}
    | mul_expression '/' neg_expression {handleErrorNotImplemented(this, $2.token);}
    ;

neg_expression: toplevel_expression {$$ = $1;}
    | '-' neg_expression {handleErrorNotImplemented(this, $1.token.location, L"unary -");}
    | '+' neg_expression {handleErrorNotImplemented(this, $1.token.location, L"unary +");}
    ;

toplevel_expression: StringLiteral {$$ = ParserValueType(AST::StringLiteralExpression::make($1.token.svalue));}
    | IntegerLiteral {$$ = ParserValueType(AST::IntegerLiteralExpression::make($1.token.svalue));}
    | SingleLiteral {$$ = ParserValueType(AST::SingleLiteralExpression::make($1.token.getFloatingPointLiteralValue()));}
    | DoubleLiteral {$$ = ParserValueType(AST::DoubleLiteralExpression::make($1.token.getFloatingPointLiteralValue()));}
    | True {$$ = ParserValueType(AST::BooleanLiteralExpression::make(true));}
    | False {$$ = ParserValueType(AST::BooleanLiteralExpression::make(false));}
    | '(' expression ')' {$$ = $2;}
    | Abs '(' expression ')' {handleErrorNotImplemented(this, $1.token);}
    | Asc '(' expression ')' {handleErrorNotImplemented(this, $1.token);}
    | ATn '(' expression ')' {handleErrorNotImplemented(this, $1.token);}
    | Chr '(' expression ')' {handleErrorNotImplemented(this, $1.token);}
    | Cos '(' expression ')' {handleErrorNotImplemented(this, $1.token);}
    | CBool '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make(dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeBoolean::getInstance(), false, [&](const wstring &msg){::handleError(this, $1.token.location, msg);}));}
    | CU8/*=CByte*/ '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make(dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeUInt8::getInstance(), false, [&](const wstring &msg){::handleError(this, $1.token.location, msg);}));}
    | CU16 '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make(dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeUInt16::getInstance(), false, [&](const wstring &msg){::handleError(this, $1.token.location, msg);}));}
    | CU32 '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make(dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeUInt16::getInstance(), false, [&](const wstring &msg){::handleError(this, $1.token.location, msg);}));}
    | CU64 '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make(dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeUInt16::getInstance(), false, [&](const wstring &msg){::handleError(this, $1.token.location, msg);}));}
    | CSng '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make(dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeSingle::getInstance(), false, [&](const wstring &msg){::handleError(this, $1.token.location, msg);}));}
    | CStr '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make(dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeString::getInstance(), false, [&](const wstring &msg){::handleError(this, $1.token.location, msg);}));}
    | CDbl '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make(dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeDouble::getInstance(), false, [&](const wstring &msg){::handleError(this, $1.token.location, msg);}));}
    | CInt '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make(dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeInteger::getInstance(), false, [&](const wstring &msg){::handleError(this, $1.token.location, msg);}));}
    | CI8 '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make(dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeInt8::getInstance(), false, [&](const wstring &msg){::handleError(this, $1.token.location, msg);}));}
    | CI16 '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make(dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeInt16::getInstance(), false, [&](const wstring &msg){::handleError(this, $1.token.location, msg);}));}
    | CI32 '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make(dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeInt32::getInstance(), false, [&](const wstring &msg){::handleError(this, $1.token.location, msg);}));}
    | CI64 '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make(dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeInt64::getInstance(), false, [&](const wstring &msg){::handleError(this, $1.token.location, msg);}));}
    | Cast '(' type ',' expression ')' {$$ = ParserValueType(AST::CastExpression::make(dynamic_pointer_cast<AST::Expression>($5.node), dynamic_pointer_cast<const AST::Type>($3.node), false, [&](const wstring &msg){::handleError(this, $1.token.location, msg);}));}
    | Exp '(' expression ')' {handleErrorNotImplemented(this, $1.token);}
    | Hex '(' expression ')' {handleErrorNotImplemented(this, $1.token);}
    | Id {const AST::Symbol &symbol = getSymbolGlobal(this, $1.token); if(symbol.stype() != AST::Symbol::Type::AutoVariable && symbol.stype() != AST::Symbol::Type::ReferenceVariable && symbol.stype() != AST::Symbol::Type::StaticVariable && symbol.stype() != AST::Symbol::Type::Procedure) ::handleError(this, $1.token.location, $1.token.svalue + L" is not a variable or procedure"); $$ = ParserValueType(symbol.value);}
    | toplevel_expression '[' expression ']' {handleErrorNotImplemented(this, $2.token.location, L"array index");}
    | toplevel_expression '(' fn_arg_list ')' {handleErrorNotImplemented(this, $1.token.location, L"Function call");}
    | Instr '(' expression ',' expression ')' {handleErrorNotImplemented(this, $1.token);}
    | Instr '(' expression ',' expression ',' expression ')' {handleErrorNotImplemented(this, $1.token);}
    | LBound '(' expression ')' {handleErrorNotImplemented(this, $1.token);}
    | LBound '(' expression ',' expression ')' {handleErrorNotImplemented(this, $1.token);}
    | LCase '(' expression ')' {handleErrorNotImplemented(this, $1.token);}
    | Left '(' expression ',' expression ')' {handleErrorNotImplemented(this, $1.token);}
    | Mid '(' expression ',' expression ',' expression ')' {handleErrorNotImplemented(this, $1.token);}
    | Mid '(' expression ',' expression ')' {handleErrorNotImplemented(this, $1.token);}
    | Oct '(' expression ')' {handleErrorNotImplemented(this, $1.token);}
    | Right '(' expression ',' expression ')' {handleErrorNotImplemented(this, $1.token);}
    | RTrim '(' expression ')' {handleErrorNotImplemented(this, $1.token);}
    | Sgn '(' expression ')' {handleErrorNotImplemented(this, $1.token);}
    | Sin '(' expression ')' {handleErrorNotImplemented(this, $1.token);}
    | Space '(' expression ')' {handleErrorNotImplemented(this, $1.token);}
    | String '(' expression ',' expression ')' {handleErrorNotImplemented(this, $1.token);}
    | Tan '(' expression ')' {handleErrorNotImplemented(this, $1.token);}
    | UBound '(' expression ')' {handleErrorNotImplemented(this, $1.token);}
    | UBound '(' expression ',' expression ')' {handleErrorNotImplemented(this, $1.token);}
    | UCase '(' expression ')' {handleErrorNotImplemented(this, $1.token);}
    | Val '(' expression ')' {handleErrorNotImplemented(this, $1.token);}
    ;

fn_arg_list: {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{});}
    | fn_arg_list_non_empty {$$ = $1;}
    ;

fn_arg_list_non_empty: expression {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{$1.node});}
    | fn_arg_list_non_empty ',' expression {$$ = $1; $$.nodes.push_back($3.node);}
    ;

fn_decl_arg_list: {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{});}
    | fn_decl_arg_list_non_empty {$$ = $1;}
    ;

fn_decl_arg_list_non_empty: Id As type {handleErrorNotImplemented(this, $1.token.location, L"procedure argument");}
    | As type {handleErrorNotImplemented(this, $1.token.location, L"procedure argument");}
    | fn_decl_arg_list_non_empty ',' As type {handleErrorNotImplemented(this, $1.token.location, L"procedure argument");}
    | fn_decl_arg_list_non_empty ',' Id As type {handleErrorNotImplemented(this, $1.token.location, L"procedure argument");}
    ;

type: Boolean {$$ = ParserValueType(AST::TypeBoolean::getInstance());}
    | Integer {$$ = ParserValueType(AST::TypeInteger::getInstance());}
    | Int8  {$$ = ParserValueType(AST::TypeInt8::getInstance());}
    | Int16  {$$ = ParserValueType(AST::TypeInt16::getInstance());}
    | Int32  {$$ = ParserValueType(AST::TypeInt32::getInstance());}
    | Int64  {$$ = ParserValueType(AST::TypeInt64::getInstance());}
    | Single  {$$ = ParserValueType(AST::TypeSingle::getInstance());}
    | String  {$$ = ParserValueType(AST::TypeString::getInstance());}
    | UInt8/*= Byte*/  {$$ = ParserValueType(AST::TypeUInt8::getInstance());}
    | UInt16  {$$ = ParserValueType(AST::TypeUInt16::getInstance());}
    | UInt32  {$$ = ParserValueType(AST::TypeUInt32::getInstance());}
    | UInt64  {$$ = ParserValueType(AST::TypeUInt64::getInstance());}
    | ByRef type {$$ = ParserValueType(); handleErrorNotImplemented(this, $1.token);}
    | ByVal type {$$ = ParserValueType(dynamic_pointer_cast<const AST::Type>($2.node)->toRValue());}
    | Function '(' fn_decl_arg_list ')' As type {handleErrorNotImplemented(this, $1.token.location, L"Function type");}
    | Sub '(' fn_decl_arg_list ')' {handleErrorNotImplemented(this, $1.token.location, L"Sub type");}
    | TypeOf '(' expression ')' {$$ = ParserValueType(dynamic_pointer_cast<AST::Expression>($3.node)->type()->toRValue());}
    | Id {const AST::Symbol &symbol = getSymbolGlobal(this, $1.token); if(symbol.stype() != AST::Symbol::Type::Type) ::handleError(this, $1.token.location, $1.token.svalue + L" is not a type"); $$ = ParserValueType(symbol.value);}
    ;

newLine: '\n' {}
    | EOF {}
    | newLine '\n' {}
    ;
%%
%{
#include <cwctype>
#include <cassert>
#include <sstream>
#include "string_cast.h"

using namespace std;

class Parser : public ParserBase
{
    Tokenizer tokenizer;
public:
    void handleError(Location location, const wstring &msg) const
    {
        wostringstream ss;
        ss << location.fileName << L":" << location.line << L":" << location.col << L": error: " << msg;
        throw ParseError(string_cast<string>(ss.str()));
    }
    explicit Parser(shared_ptr<InputStream> is)
        : tokenizer(is)
    {
    }
    vector<AST::SymbolTable> symbolTableStack;
protected:
    virtual ParserValueType getToken() override
    {
        return ParserValueType(tokenizer.getToken());
    }
};

vector<AST::SymbolTable> &getSymbolTableStack(ParserBase *parser)
{
    Parser *theParser = dynamic_cast<Parser *>(parser);
    assert(theParser != nullptr);
    return theParser->symbolTableStack;
}

ParserValueType parseAll(shared_ptr<InputStream> is)
{
    return Parser(is).parse();
}

void handleError(ParserBase *parser, Location location, const wstring &msg)
{
    Parser *theParser = dynamic_cast<Parser *>(parser);
    assert(theParser != nullptr);
    theParser->handleError(location, msg);
}

%}