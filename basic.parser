%{
#include <cstdint>
#include <cwchar>
#include <string>
#include <memory>
#include <iostream>
#include <vector>
#include <cassert>
#include "tokenizer.h"
#include "ast/all.h"

using namespace std;

struct ParserValueType final
{
    Token token;
    shared_ptr<AST::Base> node;
    vector<shared_ptr<AST::Base>> nodes; // for lists
    explicit ParserValueType(TokenType tokenType = TokenType::TTEOF)
        : token(tokenType), node(nullptr)
    {
    }
    explicit ParserValueType(char tokenType)
        : token((TokenType)tokenType), node(nullptr)
    {
    }
    explicit ParserValueType(Token token)
        : token(token), node(nullptr)
    {
    }
    explicit ParserValueType(shared_ptr<const AST::Base> node)
        : token(), node(const_pointer_cast<AST::Base>(node))
    {
    }
    explicit ParserValueType(vector<shared_ptr<AST::Base>> nodes)
        : token(), node(nullptr), nodes(nodes)
    {
    }
    bool operator ==(const ParserValueType &rt) const
    {
        return token.type == rt.token.type && node == rt.node;
    }
    bool operator !=(const ParserValueType &rt) const
    {
        return token.type != rt.token.type || node != rt.node;
    }
};

class ParserBase;

vector<shared_ptr<AST::SymbolTable>> &getSymbolTableStack(ParserBase *parser);

inline bool symbolExistsGlobal(ParserBase *parser, const wstring &name)
{
    vector<shared_ptr<AST::SymbolTable>> &sts = getSymbolTableStack(parser);
    for(auto i = sts.rbegin(); i != sts.rend(); ++i)
    {
        if((*i)->exists(name))
            return true;
    }
    return false;
}

inline void handleError(Location location, const wstring &msg)
{
    throw ParserError(location, msg);
}

inline void handleErrorNotImplemented(Location location, const wstring &what)
{
    handleError(location, what + L" not implemented");
}

inline void handleErrorNotImplemented(Token t)
{
    handleErrorNotImplemented(t.location, t.svalue);
}

inline const AST::Symbol &getSymbolGlobal(ParserBase *parser, Location location, const wstring &name)
{
    vector<shared_ptr<AST::SymbolTable>> &sts = getSymbolTableStack(parser);
    for(auto i = sts.rbegin(); i != sts.rend(); ++i)
    {
        if((*i)->exists(name))
            return (*i)->get(name);
    }
    handleError(location, L"undeclared identifier : " + name);
    throw logic_error("shouldn't be here");
}

inline const AST::Symbol &getSymbolGlobal(ParserBase *parser, Token t)
{
    return getSymbolGlobal(parser, t.location, t.svalue);
}

shared_ptr<AST::CodeBlock> parseAll(shared_ptr<InputStream> is);

%}
%option SymbolPrefix "TokenType::TT"
%option ValueType "ParserValueType"
%option "UseC++11"
%option "ClassName" "ParserBase"
%token Id
%token StringLiteral
%token IntegerLiteral
%token SingleLiteral
%token DoubleLiteral
%token LogicalGE
%token LogicalLE
%token LogicalNE
%token Abs
%token And
%token As
%token Asc
%token ATn
%token Boolean
%token ByRef
%token ByVal
%token Case
%token Cast
%token CBool
%token CDbl
%token CInt
%token CI8
%token CI16
%token CI32
%token CI64
%token CPtr
%token CSng
%token CStr
%token CU8
//%token CByte
%token CU16
%token CU32
%token CU64
%token Chr
%token Cos
%token Dim
%token Declare
%token Do
%token Double
%token Else
%token ElseIf
%token End
%token Exit
%token Exp
%token False
%token For
%token Function
%token Hex
%token If
%token InStr
%token Int
%token Integer
%token Int8
%token Int16
%token Int32
%token Int64
%token Is
%token LBound
%token LCase
%token Left
%token Len
%token Log
%token Loop
%token LTrim
%token Mid
%token Mod
%token Next
%token Not
%token Oct
%token Or
%token Pointer
%token Right
%token RTrim
%token Select
%token Sgn
%token Sin
%token Single
%token Space
%token Sqr
%token Static
%token Step
%token Str
%token String
%token Sub
%token Tan
%token Then
%token To
%token True
%token Type
%token TypeOf
%token UBound
%token UCase
%token UInt8
//%token Byte
%token UInt16
%token UInt32
%token UInt64
%token Until
%token Val
%token WEnd
%token While
%token Xor
%%

program: codeBlock {$$ = $1;}
    | newLine codeBlock {$$ = $2;}
    ;

variableDeclaration: Dim {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{});}
    | Dim declarationPartList {$$ = $2;}
    ;

declaration: variableDeclaration {$$ = $1;}
    | Type Id newLine typeDefinitionBlock End Type {handleErrorNotImplemented($1.token);}
    | procedureDefinition {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{$1.node});}
    | procedureDeclaration {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{$1.node});}
    ;

typeDefinitionBlock: {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{});}
    | typeDefinitionPartList newLine {$$ = $1;}
    ;

typeDefinitionPartList: typeDefinitionPart {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{$1.node});}
    | typeDefinitionPartList ',' typeDefinitionPart {$$ = $1; $$.nodes.push_back($1.node);}
    ;

procedureDefinition: Sub Id '(' fn_decl_arg_list ')' codeBlockWithNewLine End Sub {handleErrorNotImplemented($1.token);}
    | Function Id '(' fn_decl_arg_list ')' As type codeBlockWithNewLine End Function {handleErrorNotImplemented($1.token);}
    ;

procedureDeclaration: Declare Sub Id '(' fn_decl_arg_list ')' {handleErrorNotImplemented($1.token.location, L"Declare Sub");}
    | Declare Function Id '(' fn_decl_arg_list ')' As type {handleErrorNotImplemented($1.token.location, L"Declare Function");}
    ;

typeDefinitionPart: Id As type {handleErrorNotImplemented($1.token.location, L"Type");}
    | procedureDefinition {$$ = $1;}
    ;

declarationPartList: declarationPart {$$ = $1;}
    | declarationPartList ',' declarationPart {$$ = $1; $$.nodes.insert($$.nodes.end(), $3.nodes.begin(), $3.nodes.end());}
    ;

declarationPart: Id '=' expression
    {
        shared_ptr<AST::Expression> rhs = dynamic_pointer_cast<AST::Expression>($3.node);
        shared_ptr<const AST::Type> type = dynamic_pointer_cast<const AST::Type>(rhs->type()->toRValue());
        wstring name = $1.token.svalue;
        Location location = $1.token.location;
        shared_ptr<AST::Variable> variable;
        AST::Symbol::Type stype;
        if(type->isLValue())
        {
            handleErrorNotImplemented(location, L"ByRef variable");
        }
        else
        {
            type = AST::TypeReference::make(location, type);
            variable = AST::AutoVariable::make(location, type, name, rhs);
            stype = AST::Symbol::Type::AutoVariable;
        }
        vector<shared_ptr<AST::SymbolTable>> &sts = getSymbolTableStack(this);
        assert(!sts.empty());
        if(sts.back()->exists(name))
            ::handleError(location, name + L" already defined");
        sts.back()->make(AST::Symbol(name, stype, type, variable));
        $$ = ParserValueType(vector<shared_ptr<AST::Base>>{variable});
    }
    | Id As type
    {
        shared_ptr<const AST::Type> type = dynamic_pointer_cast<const AST::Type>($3.node);
        wstring name = $1.token.svalue;
        Location location = $1.token.location;
        shared_ptr<AST::Variable> variable;
        AST::Symbol::Type stype;
        if(type->isLValue())
        {
            ::handleError(location, L"ByRef variable must have initializer");
        }
        else
        {
            type = AST::TypeReference::make(location, type);
            variable = AST::AutoVariable::make(location, type, name, nullptr);
            stype = AST::Symbol::Type::AutoVariable;
        }
        vector<shared_ptr<AST::SymbolTable>> &sts = getSymbolTableStack(this);
        assert(!sts.empty());
        if(sts.back()->exists(name))
            ::handleError(location, name + L" already defined");
        sts.back()->make(AST::Symbol(name, stype, type, variable));
        $$ = ParserValueType(vector<shared_ptr<AST::Base>>{variable});
    }
    | Id As type '=' expression
    {
        shared_ptr<const AST::Type> type = dynamic_pointer_cast<const AST::Type>($3.node);
        wstring name = $1.token.svalue;
        Location location = $1.token.location;
        shared_ptr<AST::Variable> variable;
        AST::Symbol::Type stype;
        if(type->isLValue())
        {
            type = AST::TypeReference::make(location, type);
            variable = AST::ReferenceVariable::make(location, type, name, dynamic_pointer_cast<AST::Expression>($5.node));
            stype = AST::Symbol::Type::ReferenceVariable;
        }
        else
        {
            type = AST::TypeReference::make(location, type);
            variable = AST::AutoVariable::make(location, type, name, dynamic_pointer_cast<AST::Expression>($5.node));
            stype = AST::Symbol::Type::AutoVariable;
        }
        vector<shared_ptr<AST::SymbolTable>> &sts = getSymbolTableStack(this);
        assert(!sts.empty());
        if(sts.back()->exists(name))
            ::handleError(location, name + L" already defined");
        sts.back()->make(AST::Symbol(name, stype, type, variable));
        $$ = ParserValueType(vector<shared_ptr<AST::Base>>{variable});
    }
    ;

codeBlockWithNewLine: newLine codeBlock {$$ = $2;}
    ;

codeBlock: codeBlockInternal
    {
        shared_ptr<AST::SymbolTable> st = getSymbolTableStack(this).back();
        getSymbolTableStack(this).pop_back();
        vector<shared_ptr<AST::Statement>> statements;
        for(shared_ptr<AST::Base> n : $1.nodes)
            statements.push_back(dynamic_pointer_cast<AST::Statement>(n));
        $$ = ParserValueType(AST::CodeBlock::make($1.token.location, st, statements));
    }
    ;

codeBlockInternal: {getSymbolTableStack(this).push_back(AST::SymbolTable::make()); $$ = ParserValueType(vector<shared_ptr<AST::Base>>{}); $$.token.location = peekToken.token.location;}
    | codeBlockInternal statementList newLine {$$ = $1; $$.nodes.insert($$.nodes.end(), $2.nodes.begin(), $2.nodes.end());}
    | codeBlockInternal declaration newLine {$$ = $1; $$.nodes.insert($$.nodes.end(), $2.nodes.begin(), $2.nodes.end());}
    ;

statementList: statement {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{$1.node});}
    | restOfLineStatementList {$$ = $1;}
    ;

restOfLineStatementList: inlineStatementList {$$ = $1;}
    | inlineStatementList ':' restOfLineStatement {$$ = $1; $$.nodes.push_back($3.node);}
    | restOfLineStatement {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{$1.node});}
    ;

inlineStatementList: inlineStatement {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{$1.node});}
    | inlineStatementList ':' inlineStatement {$$ = $1; $$.nodes.push_back($3.node);}
    ;

statement: ifStatement {$$ = $1;}
    | Do While expression codeBlockWithNewLine Loop
    {
        $$ = ParserValueType(AST::DoStatement::make($1.token.location,
                                                       dynamic_pointer_cast<AST::Expression>($3.node),
                                                       AST::DoStatement::ConditionType::DoWhile,
                                                       dynamic_pointer_cast<AST::CodeBlock>($4.node)));
    }
    | Do Until expression codeBlockWithNewLine Loop
    {
        $$ = ParserValueType(AST::DoStatement::make($1.token.location,
                                                       dynamic_pointer_cast<AST::Expression>($3.node),
                                                       AST::DoStatement::ConditionType::DoUntil,
                                                       dynamic_pointer_cast<AST::CodeBlock>($4.node)));
    }
    | Do codeBlockWithNewLine Loop While expression
    {
        $$ = ParserValueType(AST::DoStatement::make($1.token.location,
                                                       dynamic_pointer_cast<AST::Expression>($5.node),
                                                       AST::DoStatement::ConditionType::LoopWhile,
                                                       dynamic_pointer_cast<AST::CodeBlock>($2.node)));
    }
    | Do codeBlockWithNewLine Loop Until expression
    {
        $$ = ParserValueType(AST::DoStatement::make($1.token.location,
                                                       dynamic_pointer_cast<AST::Expression>($5.node),
                                                       AST::DoStatement::ConditionType::LoopUntil,
                                                       dynamic_pointer_cast<AST::CodeBlock>($2.node)));
    }
    | Do codeBlockWithNewLine Loop
    {
        $$ = ParserValueType(AST::DoStatement::make($1.token.location,
                                                       nullptr,
                                                       AST::DoStatement::ConditionType::None,
                                                       dynamic_pointer_cast<AST::CodeBlock>($2.node)));
    }
    | While expression codeBlockWithNewLine WEnd
    {
        $$ = ParserValueType(AST::WhileStatement::make($1.token.location,
                                                       dynamic_pointer_cast<AST::Expression>($2.node),
                                                       dynamic_pointer_cast<AST::CodeBlock>($3.node)));
    }
    | For expression_no_equals '=' expression To expression codeBlockWithNewLine Next {handleErrorNotImplemented($1.token);}
    | For expression_no_equals '=' expression To expression Step expression codeBlockWithNewLine Next {handleErrorNotImplemented($1.token);}
    | For Dim Id '=' expression To expression codeBlockWithNewLine Next {handleErrorNotImplemented($1.token);}
    | For Dim Id '=' expression To expression Step expression codeBlockWithNewLine Next {handleErrorNotImplemented($1.token);}
    ;

inlineStatement: expression_no_equals '=' expression {$$ = ParserValueType(AST::AssignStatement::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node)));}
    | Exit Do {handleErrorNotImplemented($1.token.location, L"Exit Do");}
    | Exit While {handleErrorNotImplemented($1.token.location, L"Exit While");}
    | Exit For {handleErrorNotImplemented($1.token.location, L"Exit For");}
    | Exit Sub {handleErrorNotImplemented($1.token.location, L"Exit Sub");}
    | Exit Function {handleErrorNotImplemented($1.token.location, L"Exit Function");}
    | expression_no_equals {$$ = $1;}
    ;

restOfLineStatement: If expression Then restOfLineStatementList {handleErrorNotImplemented($1.token);}
    | If expression Then inlineStatementList Else restOfLineStatementList {handleErrorNotImplemented($1.token);}
    ;

ifStatement: ifStatementInternal End If {$$ = $1; dynamic_pointer_cast<AST::IfStatement>($$.node)->checkTypes();}
    | ifStatementInternal Else codeBlockWithNewLine End If
    {
        $$ = $1;
        shared_ptr<AST::IfStatement> s = dynamic_pointer_cast<AST::IfStatement>($$.node);
        s->elseSection = dynamic_pointer_cast<AST::CodeBlock>($3.node);
        s->checkTypes();
    }
    ;

ifStatementInternal: If expression Then codeBlockWithNewLine
    {
        $$ = ParserValueType(AST::IfStatement::make($1.token.location,
                                                    vector<pair<shared_ptr<AST::Expression>, shared_ptr<AST::CodeBlock>>>(
                                                    {
                                                        pair<shared_ptr<AST::Expression>, shared_ptr<AST::CodeBlock>>(dynamic_pointer_cast<AST::Expression>($2.node), dynamic_pointer_cast<AST::CodeBlock>($4.node))
                                                    })));
    }
    | ifStatementInternal ElseIf expression Then codeBlockWithNewLine
    {
        $$ = $1;
        shared_ptr<AST::IfStatement> s = dynamic_pointer_cast<AST::IfStatement>($$.node);
        s->ifSections.push_back(pair<shared_ptr<AST::Expression>, shared_ptr<AST::CodeBlock>>(dynamic_pointer_cast<AST::Expression>($3.node), dynamic_pointer_cast<AST::CodeBlock>($5.node)));
    }
    ;

elseSection:
    | Else codeBlockWithNewLine {handleErrorNotImplemented($1.token);}
    | ElseIf expression Then codeBlockWithNewLine elseSection {handleErrorNotImplemented($1.token);}
    ;

expression: or_expression {$$ = $1;}
    ;

expression_no_equals: or_expression_no_equals {$$ = $1;}
    ;

or_expression: xor_expression {$$ = $1;}
    | or_expression Or xor_expression {$$ = ParserValueType(AST::OrExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node)));}
    ;

or_expression_no_equals: xor_expression_no_equals {$$ = $1;}
    | or_expression_no_equals Or xor_expression_no_equals {$$ = ParserValueType(AST::OrExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node)));}
    ;

xor_expression: and_expression {$$ = $1;}
    | xor_expression Xor and_expression {$$ = ParserValueType(AST::XorExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node)));}
    ;

xor_expression_no_equals: and_expression_no_equals {$$ = $1;}
    | xor_expression_no_equals Xor and_expression_no_equals {$$ = ParserValueType(AST::XorExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node)));}
    ;

and_expression: not_expression {$$ = $1;}
    | and_expression And not_expression {$$ = ParserValueType(AST::AndExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node)));}
    ;

and_expression_no_equals: not_expression_no_equals {$$ = $1;}
    | and_expression_no_equals And not_expression_no_equals {$$ = ParserValueType(AST::AndExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node)));}
    ;

not_expression: compare_expression {$$ = $1;}
    | Not not_expression {$$ = ParserValueType(AST::NotExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($2.node)));}
    ;

not_expression_no_equals: compare_expression_no_equals {$$ = $1;}
    | Not not_expression_no_equals {$$ = ParserValueType(AST::NotExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($2.node)));}
    ;

compare_expression: add_expression {$$ = $1;}
    | compare_expression '<' add_expression
    {
        $$ = ParserValueType(AST::CompareExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), AST::CompareExpression::CType::LT, dynamic_pointer_cast<AST::Expression>($3.node)));
    }
    | compare_expression '>' add_expression
    {
        $$ = ParserValueType(AST::CompareExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), AST::CompareExpression::CType::GT, dynamic_pointer_cast<AST::Expression>($3.node)));
    }
    | compare_expression LogicalLE add_expression
    {
        $$ = ParserValueType(AST::CompareExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), AST::CompareExpression::CType::LE, dynamic_pointer_cast<AST::Expression>($3.node)));
    }
    | compare_expression LogicalGE add_expression
    {
        $$ = ParserValueType(AST::CompareExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), AST::CompareExpression::CType::GE, dynamic_pointer_cast<AST::Expression>($3.node)));
    }
    | compare_expression '=' add_expression
    {
        $$ = ParserValueType(AST::CompareExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), AST::CompareExpression::CType::Eq, dynamic_pointer_cast<AST::Expression>($3.node)));
    }
    | compare_expression LogicalNE add_expression
    {
        $$ = ParserValueType(AST::CompareExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), AST::CompareExpression::CType::NE, dynamic_pointer_cast<AST::Expression>($3.node)));
    }
    ;

compare_expression_no_equals: add_expression {$$ = $1;}
    | compare_expression_no_equals '<' add_expression
    {
        $$ = ParserValueType(AST::CompareExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), AST::CompareExpression::CType::LT, dynamic_pointer_cast<AST::Expression>($3.node)));
    }
    | compare_expression_no_equals '>' add_expression
    {
        $$ = ParserValueType(AST::CompareExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), AST::CompareExpression::CType::GT, dynamic_pointer_cast<AST::Expression>($3.node)));
    }
    | compare_expression_no_equals LogicalLE add_expression
    {
        $$ = ParserValueType(AST::CompareExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), AST::CompareExpression::CType::LE, dynamic_pointer_cast<AST::Expression>($3.node)));
    }
    | compare_expression_no_equals LogicalGE add_expression
    {
        $$ = ParserValueType(AST::CompareExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), AST::CompareExpression::CType::GE, dynamic_pointer_cast<AST::Expression>($3.node)));
    }
    | compare_expression_no_equals LogicalNE add_expression
    {
        $$ = ParserValueType(AST::CompareExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), AST::CompareExpression::CType::NE, dynamic_pointer_cast<AST::Expression>($3.node)));
    }
    ;

add_expression: mod_expression {$$ = $1;}
    | add_expression '+' mod_expression {$$ = ParserValueType(AST::AddExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node)));}
    | add_expression '-' mod_expression {$$ = ParserValueType(AST::SubExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node)));}
    ;

mod_expression: mul_expression {$$ = $1;}
    | mod_expression Mod mul_expression {$$ = ParserValueType(AST::ModExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node)));}
    | mod_expression '\\' mul_expression {$$ = ParserValueType(AST::IDivExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node)));}
    ;

mul_expression: neg_expression {$$ = $1;}
    | mul_expression '*' neg_expression {$$ = ParserValueType(AST::MulExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node)));}
    | mul_expression '/' neg_expression {$$ = ParserValueType(AST::FDivExpression::make($2.token.location, dynamic_pointer_cast<AST::Expression>($1.node), dynamic_pointer_cast<AST::Expression>($3.node)));}
    ;

neg_expression: toplevel_expression {$$ = $1;}
    | '-' neg_expression {$$ = ParserValueType(AST::NegExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($2.node)));}
    | '+' neg_expression {$$ = ParserValueType(AST::UnaryPlusExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($2.node)));}
    ;

toplevel_expression: StringLiteral {$$ = ParserValueType(AST::StringLiteralExpression::make($1.token.location, $1.token.svalue));}
    | IntegerLiteral {$$ = ParserValueType(AST::IntegerLiteralExpression::make($1.token.location, $1.token.svalue, ::handleError));}
    | SingleLiteral {$$ = ParserValueType(AST::SingleLiteralExpression::make($1.token.location, $1.token.getFloatingPointLiteralValue()));}
    | DoubleLiteral {$$ = ParserValueType(AST::DoubleLiteralExpression::make($1.token.location, $1.token.getFloatingPointLiteralValue()));}
    | True {$$ = ParserValueType(AST::BooleanLiteralExpression::make($1.token.location, true));}
    | False {$$ = ParserValueType(AST::BooleanLiteralExpression::make($1.token.location, false));}
    | '(' expression ')' {$$ = $2;}
    | Abs '(' expression ')' {handleErrorNotImplemented($1.token);}
    | Asc '(' expression ')' {handleErrorNotImplemented($1.token);}
    | ATn '(' expression ')' {handleErrorNotImplemented($1.token);}
    | ATn '(' expression ',' expression ')' {handleErrorNotImplemented($1.token);}
    | Chr '(' expression ')' {handleErrorNotImplemented($1.token);}
    | Cos '(' expression ')' {handleErrorNotImplemented($1.token);}
    | CBool '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeBoolean::getInstance(), false));}
    | CU8/*=CByte*/ '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeUInt8::getInstance(), false));}
    | CU16 '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeUInt16::getInstance(), false));}
    | CU32 '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeUInt32::getInstance(), false));}
    | CU64 '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeUInt64::getInstance(), false));}
    | CSng '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeSingle::getInstance(), false));}
    | CStr '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeString::getInstance(), false));}
    | CDbl '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeDouble::getInstance(), false));}
    | CInt '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeInteger::getInstance(), false));}
    | CI8 '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeInt8::getInstance(), false));}
    | CI16 '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeInt16::getInstance(), false));}
    | CI32 '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeInt32::getInstance(), false));}
    | CI64 '(' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($3.node), AST::TypeInt64::getInstance(), false));}
    | Cast '(' type ',' expression ')' {$$ = ParserValueType(AST::CastExpression::make($1.token.location, dynamic_pointer_cast<AST::Expression>($5.node), dynamic_pointer_cast<const AST::Type>($3.node), false));}
    | Exp '(' expression ')' {handleErrorNotImplemented($1.token);}
    | Hex '(' expression ')' {handleErrorNotImplemented($1.token);}
    | Id {const AST::Symbol &symbol = getSymbolGlobal(this, $1.token); if(symbol.stype() != AST::Symbol::Type::AutoVariable && symbol.stype() != AST::Symbol::Type::ReferenceVariable && symbol.stype() != AST::Symbol::Type::StaticVariable && symbol.stype() != AST::Symbol::Type::Procedure) ::handleError($1.token.location, $1.token.svalue + L" is not a variable or procedure"); $$ = ParserValueType(symbol.value);}
    | toplevel_expression '[' expression ']' {handleErrorNotImplemented($2.token.location, L"array index");}
    | toplevel_expression '(' fn_arg_list ')' {handleErrorNotImplemented($1.token.location, L"Function call");}
    | InStr '(' expression ',' expression ')' {handleErrorNotImplemented($1.token);}
    | InStr '(' expression ',' expression ',' expression ')' {handleErrorNotImplemented($1.token);}
    | LBound '(' expression ')' {handleErrorNotImplemented($1.token);}
    | LBound '(' expression ',' expression ')' {handleErrorNotImplemented($1.token);}
    | LCase '(' expression ')' {handleErrorNotImplemented($1.token);}
    | Left '(' expression ',' expression ')' {handleErrorNotImplemented($1.token);}
    | Mid '(' expression ',' expression ',' expression ')' {handleErrorNotImplemented($1.token);}
    | Mid '(' expression ',' expression ')' {handleErrorNotImplemented($1.token);}
    | Oct '(' expression ')' {handleErrorNotImplemented($1.token);}
    | Right '(' expression ',' expression ')' {handleErrorNotImplemented($1.token);}
    | RTrim '(' expression ')' {handleErrorNotImplemented($1.token);}
    | Sgn '(' expression ')' {handleErrorNotImplemented($1.token);}
    | Sin '(' expression ')' {handleErrorNotImplemented($1.token);}
    | Space '(' expression ')' {handleErrorNotImplemented($1.token);}
    | Sqr '(' expression ')' {handleErrorNotImplemented($1.token);}
    | String '(' expression ',' expression ')' {handleErrorNotImplemented($1.token);}
    | Tan '(' expression ')' {handleErrorNotImplemented($1.token);}
    | UBound '(' expression ')' {handleErrorNotImplemented($1.token);}
    | UBound '(' expression ',' expression ')' {handleErrorNotImplemented($1.token);}
    | UCase '(' expression ')' {handleErrorNotImplemented($1.token);}
    | Val '(' expression ')' {handleErrorNotImplemented($1.token);}
    ;

fn_arg_list: {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{});}
    | fn_arg_list_non_empty {$$ = $1;}
    ;

fn_arg_list_non_empty: expression {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{$1.node});}
    | fn_arg_list_non_empty ',' expression {$$ = $1; $$.nodes.push_back($3.node);}
    ;

fn_decl_arg_list: {$$ = ParserValueType(vector<shared_ptr<AST::Base>>{});}
    | fn_decl_arg_list_non_empty {$$ = $1;}
    ;

fn_decl_arg_list_non_empty: Id As type {handleErrorNotImplemented($1.token.location, L"procedure argument");}
    | As type {handleErrorNotImplemented($1.token.location, L"procedure argument");}
    | fn_decl_arg_list_non_empty ',' As type {handleErrorNotImplemented($1.token.location, L"procedure argument");}
    | fn_decl_arg_list_non_empty ',' Id As type {handleErrorNotImplemented($1.token.location, L"procedure argument");}
    ;

type: Boolean {$$ = ParserValueType(AST::TypeBoolean::getInstance());}
    | Integer {$$ = ParserValueType(AST::TypeInteger::getInstance());}
    | Int8  {$$ = ParserValueType(AST::TypeInt8::getInstance());}
    | Int16  {$$ = ParserValueType(AST::TypeInt16::getInstance());}
    | Int32  {$$ = ParserValueType(AST::TypeInt32::getInstance());}
    | Int64  {$$ = ParserValueType(AST::TypeInt64::getInstance());}
    | Single  {$$ = ParserValueType(AST::TypeSingle::getInstance());}
    | String  {$$ = ParserValueType(AST::TypeString::getInstance());}
    | UInt8/*= Byte*/  {$$ = ParserValueType(AST::TypeUInt8::getInstance());}
    | UInt16  {$$ = ParserValueType(AST::TypeUInt16::getInstance());}
    | UInt32  {$$ = ParserValueType(AST::TypeUInt32::getInstance());}
    | UInt64  {$$ = ParserValueType(AST::TypeUInt64::getInstance());}
    | ByRef type {$$ = ParserValueType(AST::TypeReference::make($1.token.location, dynamic_pointer_cast<const AST::Type>($2.node)->toRValue()));}
    | ByVal type {$$ = ParserValueType(dynamic_pointer_cast<const AST::Type>($2.node)->toRValue());}
    | Function '(' fn_decl_arg_list ')' As type {handleErrorNotImplemented($1.token.location, L"Function type");}
    | Sub '(' fn_decl_arg_list ')' {handleErrorNotImplemented($1.token.location, L"Sub type");}
    | TypeOf '(' expression ')' {$$ = ParserValueType(dynamic_pointer_cast<AST::Expression>($3.node)->type()->toRValue());}
    | Id {const AST::Symbol &symbol = getSymbolGlobal(this, $1.token); if(symbol.stype() != AST::Symbol::Type::Type) ::handleError($1.token.location, $1.token.svalue + L" is not a type"); $$ = ParserValueType(symbol.value);}
    ;

newLine: '\n' {$$ = $1;}
    | newLine '\n' {$$ = $1;}
    ;
%%
%{
#include <cwctype>
#include <cassert>
#include <sstream>
#include "string_cast.h"

using namespace std;

class Parser : public ParserBase
{
    Tokenizer tokenizer;
public:
    explicit Parser(shared_ptr<InputStream> is)
        : tokenizer(is)
    {
    }
    vector<shared_ptr<AST::SymbolTable>> symbolTableStack;
    Location lastTokenLocation;
protected:
    virtual ParserValueType getToken() override
    {
        Token token = tokenizer.getToken();
        lastTokenLocation = token.location;
        return ParserValueType(token);
    }
};

vector<shared_ptr<AST::SymbolTable>> &getSymbolTableStack(ParserBase *parser)
{
    Parser *theParser = dynamic_cast<Parser *>(parser);
    assert(theParser != nullptr);
    return theParser->symbolTableStack;
}

shared_ptr<AST::CodeBlock> parseAll(shared_ptr<InputStream> is)
{
    Parser parser(is);
    try
    {
        return dynamic_pointer_cast<AST::CodeBlock>(parser.parse().node);
    }
    catch(ParserBase::ParseError &e)
    {
        throw ParserError(parser.lastTokenLocation, string_cast<wstring>(e.what()));
    }
}

%}